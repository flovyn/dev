#!/usr/bin/env python3
"""
flovyn-dev - Development workflow manager for Flovyn

Manages worktrees across multiple repos with isolated port allocation.
Each worktree gets its own set of ports for all services.
"""

import argparse
import os
import re
import shutil
import subprocess
import sys
import time
from dataclasses import dataclass
from datetime import date, datetime
from pathlib import Path
from typing import Optional

# =============================================================================
# Configuration
# =============================================================================

# Repository root (parent of dev/)
FLOVYN_ROOT = Path(__file__).resolve().parent.parent.parent
WORKTREES_DIR = FLOVYN_ROOT / "worktrees"

# Repositories to manage
REPOS = [
    "dev",
    "flovyn-server",
    "flovyn-app",
    "sdk-rust",
    "sdk-kotlin",
    "sdk-python",
]

# Base ports (offset 0 = main branch)
BASE_PORTS = {
    "APP_PORT": 3000,
    "SERVER_HTTP_PORT": 8000,
    "SERVER_GRPC_PORT": 9090,
    "SERVER_POSTGRES_PORT": 5435,
    "APP_POSTGRES_PORT": 5433,
    "NATS_PORT": 4222,
    "NATS_MONITOR_PORT": 8222,
    "JAEGER_UI_PORT": 16686,
    "JAEGER_OTLP_GRPC_PORT": 4317,
    "JAEGER_OTLP_HTTP_PORT": 4318,
}

# Files to copy from main to worktree (gitignored but needed)
UNTRACKED_FILES = [
    # "sdk-rust/examples/.env",  # Add files here if needed
]

# Documentation directories (relative to dev/)
DOCS_DIR = Path(__file__).resolve().parent.parent / "docs"
TEMPLATES_DIR = DOCS_DIR / "templates"
DESIGN_DIR = DOCS_DIR / "design"
PLANS_DIR = DOCS_DIR / "plans"
FEATURES_DIR = DOCS_DIR / "features"  # For large features
ARCHIVE_DIR = DOCS_DIR / "archive"

# Prompt templates directory
PROMPTS_DIR = DOCS_DIR / "templates" / "prompts"

# Colors for terminal output
class Colors:
    RED = "\033[0;31m"
    GREEN = "\033[0;32m"
    YELLOW = "\033[1;33m"
    BLUE = "\033[0;34m"
    CYAN = "\033[0;36m"
    NC = "\033[0m"  # No Color


def colored(text: str, color: str) -> str:
    """Return colored text if stdout is a tty."""
    if sys.stdout.isatty():
        return f"{color}{text}{Colors.NC}"
    return text


# =============================================================================
# Port Allocation (reads from .env files)
# =============================================================================

@dataclass
class PortAllocation:
    offset: int
    ports: dict[str, int]


def parse_env_file(env_path: Path) -> dict[str, str]:
    """Parse a .env file and return key-value pairs."""
    if not env_path.exists():
        return {}

    result = {}
    with open(env_path) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            if "=" in line:
                key, _, value = line.partition("=")
                result[key.strip()] = value.strip()
    return result


def get_ports_from_env(feature: str) -> Optional[PortAllocation]:
    """Get ports by reading the worktree's .env file."""
    env_path = WORKTREES_DIR / feature / "dev" / ".env"
    if not env_path.exists():
        return None

    env_vars = parse_env_file(env_path)

    ports = {}
    for port_name in BASE_PORTS:
        if port_name in env_vars:
            try:
                ports[port_name] = int(env_vars[port_name])
            except ValueError:
                pass

    if not ports:
        return None

    # Calculate offset from APP_PORT
    offset = ports.get("APP_PORT", BASE_PORTS["APP_PORT"]) - BASE_PORTS["APP_PORT"]

    return PortAllocation(offset=offset, ports=ports)


def get_next_offset() -> int:
    """Calculate next available offset by scanning existing worktrees."""
    max_offset = 0

    for feature in list_all_worktrees():
        allocation = get_ports_from_env(feature)
        if allocation and allocation.offset > max_offset:
            max_offset = allocation.offset

    return max_offset + 1


def allocate_ports(feature: str) -> PortAllocation:
    """Allocate ports for a new feature."""
    # Check if already allocated
    existing = get_ports_from_env(feature)
    if existing:
        return existing

    offset = get_next_offset()
    ports = {name: base + offset for name, base in BASE_PORTS.items()}

    return PortAllocation(offset=offset, ports=ports)


# =============================================================================
# .env Generation
# =============================================================================

def generate_env_content(feature: str, ports: dict[str, int]) -> str:
    """Generate .env file content for a worktree."""
    return f"""# Flovyn Development Environment - Feature: {feature}
# Auto-generated by flovyn-dev. Modify as needed.

# Deployment scenario
SCENARIO=self-hosted

# Application ports (unique for this worktree)
APP_PORT={ports['APP_PORT']}
SERVER_HTTP_PORT={ports['SERVER_HTTP_PORT']}
SERVER_GRPC_PORT={ports['SERVER_GRPC_PORT']}

# App URL (change for remote access)
APP_URL=http://localhost:{ports['APP_PORT']}

# PostgreSQL ports
SERVER_POSTGRES_PORT={ports['SERVER_POSTGRES_PORT']}
APP_POSTGRES_PORT={ports['APP_POSTGRES_PORT']}

# NATS ports
NATS_PORT={ports['NATS_PORT']}
NATS_MONITOR_PORT={ports['NATS_MONITOR_PORT']}

# Jaeger ports
JAEGER_UI_PORT={ports['JAEGER_UI_PORT']}
JAEGER_OTLP_GRPC_PORT={ports['JAEGER_OTLP_GRPC_PORT']}
JAEGER_OTLP_HTTP_PORT={ports['JAEGER_OTLP_HTTP_PORT']}

# Secrets
BETTER_AUTH_SECRET=dev-secret-key-for-worktree-{feature}

# Rust logging
RUST_LOG=info,flovyn_server=debug

# SDK Examples / Workers
FLOVYN_GRPC_SERVER_URL=http://localhost:{ports['SERVER_GRPC_PORT']}
FLOVYN_WORKER_TOKEN=fwt_dev_worker
FLOVYN_ORG_ID=550e8400-e29b-41d4-a716-446655440000
"""


# =============================================================================
# Git/Worktree Operations
# =============================================================================

def run_git(repo_path: Path, *args, check: bool = True, capture: bool = False) -> subprocess.CompletedProcess:
    """Run a git command in the specified repo."""
    cmd = ["git", "-C", str(repo_path)] + list(args)
    return subprocess.run(
        cmd,
        check=check,
        capture_output=capture,
        text=True,
    )


def worktree_exists(feature: str) -> bool:
    """Check if worktree directory exists."""
    return (WORKTREES_DIR / feature).exists()


def get_worktree_repos(feature: str) -> list[str]:
    """Get list of repos that have worktrees for this feature."""
    worktree_path = WORKTREES_DIR / feature
    if not worktree_path.exists():
        return []
    return [r for r in REPOS if (worktree_path / r).exists()]


def list_all_worktrees() -> list[str]:
    """List all feature worktrees."""
    if not WORKTREES_DIR.exists():
        return []
    return sorted([
        d.name for d in WORKTREES_DIR.iterdir()
        if d.is_dir() and not d.name.startswith(".")
    ])


# =============================================================================
# Documentation Helpers
# =============================================================================

def feature_to_title(feature: str) -> str:
    """Convert feature slug to title case."""
    return feature.replace("-", " ").replace("_", " ").title()


def get_date_prefix() -> str:
    """Get today's date as YYYYMMDD prefix."""
    return date.today().strftime("%Y%m%d")


def is_large_feature(feature: str) -> bool:
    """Check if feature uses large feature structure (subdirectory)."""
    return (FEATURES_DIR / feature).exists()


def find_feature_docs(feature: str) -> dict[str, list[Path]]:
    """Find all docs for a feature. Returns dict with 'design', 'plan' keys."""
    docs = {"design": [], "plan": []}

    # Check large feature structure first
    feature_dir = FEATURES_DIR / feature
    if feature_dir.exists():
        for f in feature_dir.iterdir():
            if f.suffix == ".md":
                if f.stem == "design" or f.stem.startswith("design"):
                    docs["design"].append(f)
                elif f.stem == "plan" or f.stem.startswith("plan"):
                    docs["plan"].append(f)
        return docs

    # Normalize feature name for matching (handle both dashes and underscores)
    feature_normalized = feature.replace("-", "_")

    # Check standard structure (files with feature name)
    # Pattern: YYYYMMDD_{feature}.md or {feature}.md
    if DESIGN_DIR.exists():
        for f in DESIGN_DIR.iterdir():
            if f.suffix == ".md":
                stem_normalized = f.stem.replace("-", "_")
                if feature_normalized in stem_normalized:
                    docs["design"].append(f)

    if PLANS_DIR.exists():
        for f in PLANS_DIR.iterdir():
            if f.suffix == ".md":
                stem_normalized = f.stem.replace("-", "_")
                if feature_normalized in stem_normalized:
                    docs["plan"].append(f)

    return docs


def create_design_doc(feature: str, large: bool = False) -> Optional[Path]:
    """Create design doc from template. Returns path to created doc."""
    template_path = TEMPLATES_DIR / "design.md"
    if not template_path.exists():
        return None

    template = template_path.read_text()

    # Replace placeholders
    title = feature_to_title(feature)
    date_str = date.today().strftime("%Y-%m-%d")
    date_prefix = get_date_prefix()

    content = template.replace("{Feature Title}", title)
    content = content.replace("{DATE}", date_str)
    content = content.replace("{feature}", feature)

    if large:
        # Large feature: create subdirectory
        feature_dir = FEATURES_DIR / feature
        feature_dir.mkdir(parents=True, exist_ok=True)
        doc_path = feature_dir / "design.md"
    else:
        # Standard feature: single file with date prefix
        doc_path = DESIGN_DIR / f"{date_prefix}_{feature.replace('-', '_')}.md"

    doc_path.write_text(content)
    return doc_path


def create_plan_doc(feature: str, large: bool = False, phase: Optional[str] = None) -> Optional[Path]:
    """Create plan doc from template. Returns path to created doc."""
    template_path = TEMPLATES_DIR / "plan.md"
    if not template_path.exists():
        return None

    template = template_path.read_text()

    # Replace placeholders
    title = feature_to_title(feature)
    date_str = date.today().strftime("%Y-%m-%d")
    date_prefix = get_date_prefix()
    design_file = f"{date_prefix}_{feature.replace('-', '_')}.md"

    content = template.replace("{Feature Title}", title)
    content = content.replace("{DATE}", date_str)
    content = content.replace("{DESIGN_FILE}", design_file if not large else "../design.md")
    content = content.replace("{Phase Name}", phase or "Initial")

    if large:
        # Large feature: create in subdirectory
        feature_dir = FEATURES_DIR / feature
        feature_dir.mkdir(parents=True, exist_ok=True)
        if phase:
            doc_path = feature_dir / f"plan_{phase.lower().replace(' ', '_')}.md"
        else:
            doc_path = feature_dir / "plan.md"
    else:
        # Standard feature: single file with date prefix
        doc_path = PLANS_DIR / f"{date_prefix}_{feature.replace('-', '_')}.md"

    doc_path.write_text(content)
    return doc_path


# =============================================================================
# Tmux Helpers
# =============================================================================

def tmux_session_exists(session_name: str) -> bool:
    """Check if a tmux session exists."""
    result = subprocess.run(
        ["tmux", "has-session", "-t", session_name],
        capture_output=True,
        check=False,
    )
    return result.returncode == 0


def tmux_create_session(session_name: str, working_dir: Path) -> bool:
    """Create a new tmux session. Returns True if created."""
    if tmux_session_exists(session_name):
        return False

    subprocess.run(
        ["tmux", "new-session", "-d", "-s", session_name, "-c", str(working_dir)],
        check=True,
    )
    return True


def tmux_kill_session(session_name: str) -> bool:
    """Kill a tmux session. Returns True if killed."""
    if not tmux_session_exists(session_name):
        return False

    subprocess.run(
        ["tmux", "kill-session", "-t", session_name],
        check=True,
    )
    return True


def tmux_send_keys(session_name: str, keys: str, enter: bool = True) -> None:
    """Send keys to a tmux session."""
    cmd = ["tmux", "send-keys", "-t", session_name, keys]
    if enter:
        cmd.append("Enter")
    subprocess.run(cmd, check=True)


def tmux_list_sessions() -> list[dict]:
    """List all tmux sessions with their info."""
    result = subprocess.run(
        ["tmux", "list-sessions", "-F", "#{session_name}:#{session_attached}:#{session_activity}"],
        capture_output=True,
        text=True,
        check=False,
    )
    if result.returncode != 0:
        return []

    sessions = []
    for line in result.stdout.strip().split("\n"):
        if not line:
            continue
        parts = line.split(":")
        if len(parts) >= 3:
            sessions.append({
                "name": parts[0],
                "attached": parts[1] == "1",
                "activity": int(parts[2]) if parts[2].isdigit() else 0,
            })
    return sessions


def get_initial_prompt(feature: str, design_path: Optional[Path]) -> str:
    """Generate initial prompt for Claude Code."""
    # Try to load from template
    template_path = PROMPTS_DIR / "initial.md"
    if template_path.exists():
        template = template_path.read_text()
    else:
        template = """You are working on feature: {feature}

Please read the design document to understand the feature requirements:
{design_path}

After reading the design doc:
1. Summarize the key requirements
2. Identify the implementation phases
3. Ask any clarifying questions before starting

When ready, create an implementation plan at:
{plan_path}
"""

    design_rel = design_path.relative_to(DOCS_DIR.parent) if design_path else "No design doc found"

    # Determine plan path based on feature structure
    if is_large_feature(feature):
        plan_path = f"dev/docs/features/{feature}/plan.md"
    else:
        plan_path = f"dev/docs/plans/{get_date_prefix()}_{feature.replace('-', '_')}.md"

    return template.format(
        feature=feature,
        design_path=str(design_rel),
        plan_path=plan_path,
    )


def get_resume_prompt(feature: str) -> str:
    """Generate resume prompt for Claude Code."""
    # Try to load from template
    template_path = PROMPTS_DIR / "resume.md"
    if template_path.exists():
        template = template_path.read_text()
    else:
        template = """Resuming work on feature: {feature}

Please:
1. Read the implementation plan to understand current progress
2. Identify completed tasks (marked with [x])
3. Identify the next task to work on
4. Continue implementation from where we left off

{docs_info}
"""

    # Find docs for this feature
    docs = find_feature_docs(feature)
    docs_info_lines = []

    if docs["design"]:
        for d in docs["design"]:
            docs_info_lines.append(f"Design: {d.relative_to(DOCS_DIR.parent)}")
    if docs["plan"]:
        for p in docs["plan"]:
            docs_info_lines.append(f"Plan: {p.relative_to(DOCS_DIR.parent)}")

    docs_info = "\n".join(docs_info_lines) if docs_info_lines else "No docs found"

    return template.format(
        feature=feature,
        docs_info=docs_info,
    )


# =============================================================================
# Commands
# =============================================================================

def cmd_create(args: argparse.Namespace) -> int:
    """Create worktrees for a feature."""
    feature = args.feature
    large = getattr(args, 'large', False)

    if worktree_exists(feature):
        print(colored(f"Error: Worktree '{feature}' already exists", Colors.RED))
        return 1

    print(colored(f"Creating worktree: {feature}", Colors.BLUE))
    if large:
        print(colored("  (large feature - using subdirectory structure)", Colors.YELLOW))

    # Allocate ports
    print(colored("  Allocating ports...", Colors.YELLOW))
    allocation = allocate_ports(feature)
    print(f"    Offset: {allocation.offset}")
    for name, port in allocation.ports.items():
        print(f"    {name}: {port}")

    # Create worktree directory
    worktree_path = WORKTREES_DIR / feature
    worktree_path.mkdir(parents=True, exist_ok=True)

    # Create worktrees for each repo
    created_repos = []
    for repo in REPOS:
        repo_path = FLOVYN_ROOT / repo
        if not repo_path.exists():
            print(colored(f"  Skipping {repo} (not found)", Colors.YELLOW))
            continue

        target_path = worktree_path / repo
        print(f"  Creating {repo}...", end=" ")

        try:
            # Create branch if it doesn't exist
            run_git(repo_path, "branch", feature, capture=True, check=False)

            # Create worktree
            run_git(repo_path, "worktree", "add", str(target_path), feature)
            print(colored("✓", Colors.GREEN))
            created_repos.append(repo)
        except subprocess.CalledProcessError as e:
            print(colored(f"✗ {e}", Colors.RED))
            # Continue with other repos

    # Generate .env for dev worktree
    if "dev" in created_repos:
        env_path = worktree_path / "dev" / ".env"
        print(f"  Generating {env_path.relative_to(FLOVYN_ROOT)}...", end=" ")
        env_content = generate_env_content(feature, allocation.ports)
        env_path.write_text(env_content)
        print(colored("✓", Colors.GREEN))

    # Copy untracked files
    for file_path in UNTRACKED_FILES:
        src = FLOVYN_ROOT / file_path
        dst = worktree_path / file_path
        if src.exists():
            print(f"  Copying {file_path}...", end=" ")
            dst.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(src, dst)
            print(colored("✓", Colors.GREEN))

    # Create design doc
    print(f"  Creating design doc...", end=" ")
    design_path = create_design_doc(feature, large=large)
    if design_path:
        print(colored(f"✓ ({design_path.relative_to(DOCS_DIR)})", Colors.GREEN))
    else:
        print(colored("✗ (template not found)", Colors.YELLOW))

    # Create tmux session (unless --no-session)
    no_session = getattr(args, 'no_session', False)
    if not no_session:
        print(f"  Creating tmux session...", end=" ")
        if tmux_create_session(feature, worktree_path):
            print(colored("✓", Colors.GREEN))

            # Launch Claude Code
            print(f"  Launching Claude Code...", end=" ")
            tmux_send_keys(feature, "claude")
            print(colored("✓", Colors.GREEN))

            # Wait for Claude to initialize
            time.sleep(2)

            # Send initial prompt
            print(f"  Sending initial prompt...", end=" ")
            initial_prompt = get_initial_prompt(feature, design_path)
            # Escape for tmux send-keys (use literal-string mode)
            tmux_send_keys(feature, initial_prompt)
            print(colored("✓", Colors.GREEN))
        else:
            print(colored("(already exists)", Colors.YELLOW))

    print()
    print(colored(f"Worktree '{feature}' created successfully!", Colors.GREEN))
    print()
    print("Ports:")
    print(f"  App:         http://localhost:{allocation.ports['APP_PORT']}")
    print(f"  Server HTTP: http://localhost:{allocation.ports['SERVER_HTTP_PORT']}")
    print(f"  Server gRPC: localhost:{allocation.ports['SERVER_GRPC_PORT']}")
    print(f"  Jaeger:      http://localhost:{allocation.ports['JAEGER_UI_PORT']}")

    if not no_session:
        print()
        print("Tmux session created. To attach:")
        print(f"  flovyn-dev attach {feature}")
    else:
        print()
        print("Next steps:")
        print(f"  cd {worktree_path}")
        print(f"  cd dev && mise run start   # Start infrastructure")

    return 0


def cmd_delete(args: argparse.Namespace) -> int:
    """Delete worktrees for a feature."""
    feature = args.feature

    if not worktree_exists(feature):
        print(colored(f"Error: Worktree '{feature}' does not exist", Colors.RED))
        return 1

    worktree_path = WORKTREES_DIR / feature

    if not args.force:
        # Check for uncommitted changes
        repos_with_changes = []
        for repo in get_worktree_repos(feature):
            result = run_git(worktree_path / repo, "status", "--porcelain", capture=True, check=False)
            if result.stdout.strip():
                repos_with_changes.append(repo)

        if repos_with_changes:
            print(colored("Warning: The following repos have uncommitted changes:", Colors.YELLOW))
            for repo in repos_with_changes:
                print(f"  - {repo}")
            print()
            response = input("Delete anyway? [y/N] ").strip().lower()
            if response != "y":
                print("Cancelled.")
                return 1

    print(colored(f"Deleting worktree: {feature}", Colors.BLUE))

    # Remove worktrees for each repo
    for repo in REPOS:
        repo_path = FLOVYN_ROOT / repo
        target_path = worktree_path / repo

        if not target_path.exists():
            continue

        print(f"  Removing {repo}...", end=" ")
        try:
            run_git(repo_path, "worktree", "remove", str(target_path), "--force" if args.force else None)
            print(colored("✓", Colors.GREEN))
        except subprocess.CalledProcessError:
            # Try to remove manually if git worktree fails
            try:
                shutil.rmtree(target_path)
                run_git(repo_path, "worktree", "prune", check=False)
                print(colored("✓ (manual)", Colors.GREEN))
            except Exception as e:
                print(colored(f"✗ {e}", Colors.RED))

    # Remove worktree directory if empty
    try:
        worktree_path.rmdir()
    except OSError:
        # Not empty, try to remove remaining files
        shutil.rmtree(worktree_path, ignore_errors=True)

    # Delete branches (optional)
    if args.delete_branches:
        print(colored("  Deleting branches...", Colors.YELLOW))
        for repo in REPOS:
            repo_path = FLOVYN_ROOT / repo
            if not repo_path.exists():
                continue
            result = run_git(repo_path, "branch", "-d", feature, capture=True, check=False)
            if result.returncode == 0:
                print(f"    {repo}: branch deleted")

    # Kill tmux session if exists
    if tmux_session_exists(feature):
        print(f"  Killing tmux session...", end=" ")
        tmux_kill_session(feature)
        print(colored("✓", Colors.GREEN))

    print()
    print(colored(f"Worktree '{feature}' deleted.", Colors.GREEN))
    return 0


def cmd_status(args: argparse.Namespace) -> int:
    """Show git status for a feature's worktrees."""
    feature = args.feature

    if not worktree_exists(feature):
        print(colored(f"Error: Worktree '{feature}' does not exist", Colors.RED))
        return 1

    worktree_path = WORKTREES_DIR / feature

    print(colored(f"Status for: {feature}", Colors.BLUE))
    print()

    for repo in get_worktree_repos(feature):
        repo_worktree = worktree_path / repo
        print(colored(f"[{repo}]", Colors.CYAN))

        # Get branch info
        result = run_git(repo_worktree, "branch", "--show-current", capture=True, check=False)
        branch = result.stdout.strip() if result.returncode == 0 else "unknown"

        # Get status
        result = run_git(repo_worktree, "status", "--porcelain", capture=True, check=False)
        status_lines = result.stdout.strip().split("\n") if result.stdout.strip() else []

        # Get ahead/behind
        result = run_git(repo_worktree, "rev-list", "--left-right", "--count", f"origin/{branch}...HEAD", capture=True, check=False)
        if result.returncode == 0:
            parts = result.stdout.strip().split()
            behind, ahead = int(parts[0]), int(parts[1]) if len(parts) > 1 else 0
        else:
            behind, ahead = 0, 0

        # Print summary
        status_text = colored("clean", Colors.GREEN) if not status_lines else colored(f"{len(status_lines)} changes", Colors.YELLOW)
        sync_parts = []
        if ahead:
            sync_parts.append(colored(f"↑{ahead}", Colors.GREEN))
        if behind:
            sync_parts.append(colored(f"↓{behind}", Colors.RED))
        sync_text = " ".join(sync_parts) if sync_parts else "in sync"

        print(f"  Branch: {branch}")
        print(f"  Status: {status_text}")
        print(f"  Remote: {sync_text}")

        if args.verbose and status_lines:
            print("  Changes:")
            for line in status_lines[:10]:
                print(f"    {line}")
            if len(status_lines) > 10:
                print(f"    ... and {len(status_lines) - 10} more")
        print()

    return 0


def cmd_commit(args: argparse.Namespace) -> int:
    """Commit changes across all repos in a worktree."""
    feature = args.feature
    message = args.message

    if not worktree_exists(feature):
        print(colored(f"Error: Worktree '{feature}' does not exist", Colors.RED))
        return 1

    worktree_path = WORKTREES_DIR / feature

    print(colored(f"Committing in: {feature}", Colors.BLUE))
    print(f"Message: {message}")
    print()

    committed = []
    for repo in get_worktree_repos(feature):
        repo_worktree = worktree_path / repo

        # Check for changes
        result = run_git(repo_worktree, "status", "--porcelain", capture=True, check=False)
        if not result.stdout.strip():
            continue

        print(f"  {repo}...", end=" ")

        try:
            # Stage all changes
            run_git(repo_worktree, "add", "-A")

            # Commit
            run_git(repo_worktree, "commit", "-m", message)
            print(colored("✓", Colors.GREEN))
            committed.append(repo)
        except subprocess.CalledProcessError as e:
            print(colored(f"✗ {e}", Colors.RED))

    if committed:
        print()
        print(colored(f"Committed in {len(committed)} repo(s): {', '.join(committed)}", Colors.GREEN))
    else:
        print(colored("No changes to commit.", Colors.YELLOW))

    return 0


def cmd_list(args: argparse.Namespace) -> int:
    """List all worktrees."""
    worktrees = list_all_worktrees()

    if not worktrees:
        print(colored("No worktrees found.", Colors.YELLOW))
        print(f"Create one with: flovyn-dev create <feature>")
        return 0

    print(colored("Worktrees:", Colors.BLUE))
    print()

    for feature in worktrees:
        repos = get_worktree_repos(feature)
        allocation = get_ports_from_env(feature)

        print(colored(f"  {feature}", Colors.CYAN))
        print(f"    Repos: {', '.join(repos)}")
        if allocation:
            print(f"    Ports: app={allocation.ports.get('APP_PORT', '?')}, server={allocation.ports.get('SERVER_HTTP_PORT', '?')}")
        print()

    return 0


def cmd_env(args: argparse.Namespace) -> int:
    """Show allocated ports for a feature."""
    feature = args.feature

    allocation = get_ports_from_env(feature)

    if not allocation:
        print(colored(f"Error: No .env found for '{feature}'", Colors.RED))
        print(f"Expected: {WORKTREES_DIR / feature / 'dev' / '.env'}")
        return 1

    print(colored(f"Environment for: {feature}", Colors.BLUE))
    print(f"  Offset: {allocation.offset}")
    print()
    print(colored("Ports:", Colors.CYAN))
    for name, port in sorted(allocation.ports.items()):
        print(f"  {name}={port}")

    print()
    print(colored("URLs:", Colors.CYAN))
    print(f"  App:         http://localhost:{allocation.ports.get('APP_PORT', '?')}")
    print(f"  Server HTTP: http://localhost:{allocation.ports.get('SERVER_HTTP_PORT', '?')}")
    print(f"  Server gRPC: localhost:{allocation.ports.get('SERVER_GRPC_PORT', '?')}")
    print(f"  Jaeger UI:   http://localhost:{allocation.ports.get('JAEGER_UI_PORT', '?')}")
    print(f"  NATS:        localhost:{allocation.ports.get('NATS_PORT', '?')}")

    return 0


def cmd_open(args: argparse.Namespace) -> int:
    """Open design or plan doc for a feature."""
    feature = args.feature
    doc_type = args.type  # 'design' or 'plan'

    docs = find_feature_docs(feature)

    if not docs["design"] and not docs["plan"]:
        print(colored(f"Error: No docs found for '{feature}'", Colors.RED))
        return 1

    target_docs = docs[doc_type]

    if not target_docs:
        # Try the other type if requested type not found
        other_type = "plan" if doc_type == "design" else "design"
        if docs[other_type]:
            print(colored(f"No {doc_type} doc found, but found {other_type} doc(s).", Colors.YELLOW))
            target_docs = docs[other_type]
        else:
            print(colored(f"Error: No {doc_type} doc found for '{feature}'", Colors.RED))
            return 1

    # If multiple docs, let user choose
    if len(target_docs) > 1:
        print(colored(f"Multiple {doc_type} docs found:", Colors.BLUE))
        for i, doc in enumerate(target_docs, 1):
            print(f"  {i}. {doc.name}")
        try:
            choice = int(input("Select (number): ").strip()) - 1
            if 0 <= choice < len(target_docs):
                doc_path = target_docs[choice]
            else:
                print(colored("Invalid selection.", Colors.RED))
                return 1
        except (ValueError, EOFError):
            print(colored("Invalid selection.", Colors.RED))
            return 1
    else:
        doc_path = target_docs[0]

    # Open in editor
    editor = os.environ.get("EDITOR", "vim")
    print(f"Opening {doc_path.relative_to(DOCS_DIR)} in {editor}...")
    os.execvp(editor, [editor, str(doc_path)])
    return 0


def cmd_docs(args: argparse.Namespace) -> int:
    """List docs for a feature."""
    feature = args.feature

    docs = find_feature_docs(feature)

    if not docs["design"] and not docs["plan"]:
        print(colored(f"No docs found for '{feature}'", Colors.YELLOW))
        return 0

    print(colored(f"Docs for: {feature}", Colors.BLUE))

    if is_large_feature(feature):
        print(colored("  (large feature - subdirectory structure)", Colors.YELLOW))

    print()

    if docs["design"]:
        print(colored("Design:", Colors.CYAN))
        for doc in docs["design"]:
            print(f"  {doc.relative_to(DOCS_DIR)}")

    if docs["plan"]:
        print(colored("Plan:", Colors.CYAN))
        for doc in docs["plan"]:
            print(f"  {doc.relative_to(DOCS_DIR)}")

    return 0


def cmd_docs_promote(args: argparse.Namespace) -> int:
    """Promote a feature to large feature structure."""
    feature = args.feature

    if is_large_feature(feature):
        print(colored(f"Feature '{feature}' is already a large feature.", Colors.YELLOW))
        return 0

    docs = find_feature_docs(feature)

    if not docs["design"] and not docs["plan"]:
        print(colored(f"Error: No docs found for '{feature}'", Colors.RED))
        return 1

    print(colored(f"Promoting '{feature}' to large feature structure...", Colors.BLUE))

    # Create feature directory
    feature_dir = FEATURES_DIR / feature
    feature_dir.mkdir(parents=True, exist_ok=True)

    # Move design docs
    for doc in docs["design"]:
        new_path = feature_dir / "design.md"
        print(f"  Moving {doc.name} -> features/{feature}/design.md...", end=" ")
        shutil.move(str(doc), str(new_path))
        print(colored("✓", Colors.GREEN))

    # Move plan docs
    for i, doc in enumerate(docs["plan"]):
        if len(docs["plan"]) == 1:
            new_name = "plan.md"
        else:
            new_name = f"plan_{i + 1}.md"
        new_path = feature_dir / new_name
        print(f"  Moving {doc.name} -> features/{feature}/{new_name}...", end=" ")
        shutil.move(str(doc), str(new_path))
        print(colored("✓", Colors.GREEN))

    print()
    print(colored(f"Feature '{feature}' promoted to large feature structure.", Colors.GREEN))
    print(f"  Location: {feature_dir.relative_to(DOCS_DIR)}/")
    return 0


def cmd_docs_archive(args: argparse.Namespace) -> int:
    """Archive docs for a completed feature."""
    feature = args.feature

    docs = find_feature_docs(feature)

    if not docs["design"] and not docs["plan"]:
        print(colored(f"Error: No docs found for '{feature}'", Colors.RED))
        return 1

    # Create archive directory
    date_prefix = get_date_prefix()
    archive_dir = ARCHIVE_DIR / f"{date_prefix}_{feature}"
    archive_dir.mkdir(parents=True, exist_ok=True)

    print(colored(f"Archiving docs for '{feature}'...", Colors.BLUE))

    # Archive from large feature structure
    if is_large_feature(feature):
        feature_dir = FEATURES_DIR / feature
        for doc in feature_dir.iterdir():
            if doc.suffix == ".md":
                new_path = archive_dir / doc.name
                print(f"  Moving {doc.name}...", end=" ")
                shutil.move(str(doc), str(new_path))
                print(colored("✓", Colors.GREEN))
        # Remove empty feature directory
        try:
            feature_dir.rmdir()
        except OSError:
            pass
    else:
        # Archive from standard structure
        for doc in docs["design"]:
            new_path = archive_dir / "design.md"
            print(f"  Moving {doc.name} -> design.md...", end=" ")
            shutil.move(str(doc), str(new_path))
            print(colored("✓", Colors.GREEN))

        for doc in docs["plan"]:
            new_path = archive_dir / "plan.md"
            print(f"  Moving {doc.name} -> plan.md...", end=" ")
            shutil.move(str(doc), str(new_path))
            print(colored("✓", Colors.GREEN))

    print()
    print(colored(f"Docs archived to: {archive_dir.relative_to(DOCS_DIR)}/", Colors.GREEN))
    return 0


def cmd_attach(args: argparse.Namespace) -> int:
    """Attach to a feature's tmux session."""
    feature = args.feature
    resume = not args.no_resume

    # Check if session exists
    if not tmux_session_exists(feature):
        # Check if worktree exists - offer to create session
        if worktree_exists(feature):
            print(colored(f"No tmux session for '{feature}', but worktree exists.", Colors.YELLOW))
            response = input("Create session and launch Claude? [Y/n] ").strip().lower()
            if response != "n":
                worktree_path = WORKTREES_DIR / feature
                print(f"  Creating tmux session...", end=" ")
                tmux_create_session(feature, worktree_path)
                print(colored("✓", Colors.GREEN))

                print(f"  Launching Claude Code...", end=" ")
                tmux_send_keys(feature, "claude")
                print(colored("✓", Colors.GREEN))

                time.sleep(2)

                # Send resume prompt since worktree already exists
                print(f"  Sending resume prompt...", end=" ")
                resume_prompt = get_resume_prompt(feature)
                tmux_send_keys(feature, resume_prompt)
                print(colored("✓", Colors.GREEN))
            else:
                print("Cancelled.")
                return 1
        else:
            print(colored(f"Error: No session or worktree for '{feature}'", Colors.RED))
            print(f"Create one with: flovyn-dev create {feature}")
            return 1
    elif resume:
        # Send resume prompt before attaching
        print(f"Sending resume prompt...", end=" ")
        resume_prompt = get_resume_prompt(feature)
        tmux_send_keys(feature, resume_prompt)
        print(colored("✓", Colors.GREEN))

    # Attach to session
    print(f"Attaching to session '{feature}'...")
    os.execvp("tmux", ["tmux", "attach-session", "-t", feature])
    return 0


def cmd_sessions(args: argparse.Namespace) -> int:
    """List all flovyn-related tmux sessions."""
    sessions = tmux_list_sessions()

    if not sessions:
        print(colored("No tmux sessions found.", Colors.YELLOW))
        return 0

    # Filter to only flovyn worktrees
    worktrees = set(list_all_worktrees())
    flovyn_sessions = [s for s in sessions if s["name"] in worktrees]

    if not flovyn_sessions:
        print(colored("No flovyn-related tmux sessions found.", Colors.YELLOW))
        if sessions:
            print(f"(There are {len(sessions)} other tmux sessions)")
        return 0

    print(colored("Flovyn tmux sessions:", Colors.BLUE))
    print()

    for session in flovyn_sessions:
        name = session["name"]
        attached = colored("attached", Colors.GREEN) if session["attached"] else colored("detached", Colors.YELLOW)
        activity_time = datetime.fromtimestamp(session["activity"]).strftime("%Y-%m-%d %H:%M:%S")

        print(f"  {colored(name, Colors.CYAN)}")
        print(f"    Status: {attached}")
        print(f"    Last activity: {activity_time}")
        print()

    print(f"Attach with: flovyn-dev attach <feature>")
    return 0


# =============================================================================
# Main
# =============================================================================

def main() -> int:
    parser = argparse.ArgumentParser(
        description="Flovyn development workflow manager",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  flovyn-dev create webhook-retry        Create worktrees + tmux session + Claude
  flovyn-dev create auth-system --large  Create large feature with subdirectory
  flovyn-dev create foo --no-session     Create without tmux session
  flovyn-dev attach webhook-retry        Attach to tmux session (with resume prompt)
  flovyn-dev attach webhook-retry --no-resume  Attach without sending resume prompt
  flovyn-dev sessions                    List all flovyn tmux sessions
  flovyn-dev list                        List all worktrees
  flovyn-dev status webhook-retry        Show git status
  flovyn-dev commit webhook-retry -m "feat: add retry"
  flovyn-dev env webhook-retry           Show allocated ports
  flovyn-dev open webhook-retry          Open design doc in $EDITOR
  flovyn-dev open webhook-retry plan     Open plan doc
  flovyn-dev docs list webhook-retry     List all docs for feature
  flovyn-dev docs promote webhook-retry  Convert to large feature structure
  flovyn-dev docs archive webhook-retry  Archive completed feature docs
  flovyn-dev delete webhook-retry        Delete worktrees + tmux session
        """,
    )

    subparsers = parser.add_subparsers(dest="command", required=True)

    # create
    p_create = subparsers.add_parser("create", help="Create worktrees for a feature")
    p_create.add_argument("feature", help="Feature name (used as branch name)")
    p_create.add_argument("--large", action="store_true", help="Use large feature structure (subdirectory for docs)")
    p_create.add_argument("--no-session", action="store_true", help="Don't create tmux session or launch Claude")
    p_create.set_defaults(func=cmd_create)

    # delete
    p_delete = subparsers.add_parser("delete", help="Delete worktrees for a feature")
    p_delete.add_argument("feature", help="Feature name")
    p_delete.add_argument("-f", "--force", action="store_true", help="Force delete without confirmation")
    p_delete.add_argument("--delete-branches", action="store_true", help="Also delete git branches")
    p_delete.set_defaults(func=cmd_delete)

    # status
    p_status = subparsers.add_parser("status", help="Show git status for a feature")
    p_status.add_argument("feature", help="Feature name")
    p_status.add_argument("-v", "--verbose", action="store_true", help="Show detailed changes")
    p_status.set_defaults(func=cmd_status)

    # commit
    p_commit = subparsers.add_parser("commit", help="Commit changes across repos")
    p_commit.add_argument("feature", help="Feature name")
    p_commit.add_argument("-m", "--message", required=True, help="Commit message")
    p_commit.set_defaults(func=cmd_commit)

    # list
    p_list = subparsers.add_parser("list", help="List all worktrees")
    p_list.set_defaults(func=cmd_list)

    # env
    p_env = subparsers.add_parser("env", help="Show allocated ports for a feature")
    p_env.add_argument("feature", help="Feature name")
    p_env.set_defaults(func=cmd_env)

    # open
    p_open = subparsers.add_parser("open", help="Open design or plan doc in $EDITOR")
    p_open.add_argument("feature", help="Feature name")
    p_open.add_argument("type", nargs="?", default="design", choices=["design", "plan"], help="Doc type (default: design)")
    p_open.set_defaults(func=cmd_open)

    # docs (with subcommands)
    p_docs = subparsers.add_parser("docs", help="Manage feature documentation")
    docs_subparsers = p_docs.add_subparsers(dest="docs_command", required=True)

    # docs list <feature>
    p_docs_list = docs_subparsers.add_parser("list", help="List docs for a feature")
    p_docs_list.add_argument("feature", help="Feature name")
    p_docs_list.set_defaults(func=cmd_docs)

    # docs promote <feature>
    p_docs_promote = docs_subparsers.add_parser("promote", help="Promote to large feature structure")
    p_docs_promote.add_argument("feature", help="Feature name")
    p_docs_promote.set_defaults(func=cmd_docs_promote)

    # docs archive <feature>
    p_docs_archive = docs_subparsers.add_parser("archive", help="Archive completed feature docs")
    p_docs_archive.add_argument("feature", help="Feature name")
    p_docs_archive.set_defaults(func=cmd_docs_archive)

    # attach
    p_attach = subparsers.add_parser("attach", help="Attach to a feature's tmux session")
    p_attach.add_argument("feature", help="Feature name")
    p_attach.add_argument("--no-resume", action="store_true", help="Don't send resume prompt before attaching")
    p_attach.set_defaults(func=cmd_attach)

    # sessions
    p_sessions = subparsers.add_parser("sessions", help="List all flovyn-related tmux sessions")
    p_sessions.set_defaults(func=cmd_sessions)

    args = parser.parse_args()
    return args.func(args)


if __name__ == "__main__":
    sys.exit(main())
