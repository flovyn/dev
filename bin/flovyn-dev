#!/usr/bin/env python3
"""
flovyn-dev - Development workflow manager for Flovyn

Manages worktrees across multiple repos with isolated port allocation.
Each worktree gets its own set of ports for all services.
"""

import argparse
import json
import os
import shutil
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

# =============================================================================
# Configuration
# =============================================================================

# Repository root (parent of dev/)
FLOVYN_ROOT = Path(__file__).resolve().parent.parent.parent
WORKTREES_DIR = FLOVYN_ROOT / "worktrees"
PORTS_FILE = Path.home() / ".flovyn" / "ports.json"

# Repositories to manage
REPOS = [
    "dev",
    "flovyn-server",
    "flovyn-app",
    "sdk-rust",
    "sdk-kotlin",
    "sdk-python",
]

# Base ports (offset 0 = main branch)
BASE_PORTS = {
    "APP_PORT": 3000,
    "SERVER_HTTP_PORT": 8000,
    "SERVER_GRPC_PORT": 9090,
    "SERVER_POSTGRES_PORT": 5435,
    "APP_POSTGRES_PORT": 5433,
    "NATS_PORT": 4222,
    "NATS_MONITOR_PORT": 8222,
    "JAEGER_UI_PORT": 16686,
    "JAEGER_OTLP_GRPC_PORT": 4317,
    "JAEGER_OTLP_HTTP_PORT": 4318,
}

# Files to copy from main to worktree (gitignored but needed)
UNTRACKED_FILES = [
    # "sdk-rust/examples/.env",  # Add files here if needed
]

# Colors for terminal output
class Colors:
    RED = "\033[0;31m"
    GREEN = "\033[0;32m"
    YELLOW = "\033[1;33m"
    BLUE = "\033[0;34m"
    CYAN = "\033[0;36m"
    NC = "\033[0m"  # No Color


def colored(text: str, color: str) -> str:
    """Return colored text if stdout is a tty."""
    if sys.stdout.isatty():
        return f"{color}{text}{Colors.NC}"
    return text


# =============================================================================
# Port Allocation
# =============================================================================

@dataclass
class PortAllocation:
    offset: int
    ports: dict[str, int]


def load_ports() -> dict:
    """Load port allocations from file."""
    if not PORTS_FILE.exists():
        return {"allocations": {}, "next_offset": 1}
    with open(PORTS_FILE) as f:
        return json.load(f)


def save_ports(data: dict) -> None:
    """Save port allocations to file."""
    PORTS_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(PORTS_FILE, "w") as f:
        json.dump(data, f, indent=2)


def allocate_ports(feature: str) -> PortAllocation:
    """Allocate ports for a new feature."""
    data = load_ports()

    if feature in data["allocations"]:
        alloc = data["allocations"][feature]
        return PortAllocation(
            offset=alloc["offset"],
            ports={k: v for k, v in alloc.items() if k != "offset"}
        )

    offset = data["next_offset"]
    ports = {name: base + offset for name, base in BASE_PORTS.items()}

    data["allocations"][feature] = {"offset": offset, **ports}
    data["next_offset"] = offset + 1
    save_ports(data)

    return PortAllocation(offset=offset, ports=ports)


def release_ports(feature: str) -> bool:
    """Release ports for a feature."""
    data = load_ports()
    if feature in data["allocations"]:
        del data["allocations"][feature]
        save_ports(data)
        return True
    return False


def get_ports(feature: str) -> Optional[PortAllocation]:
    """Get allocated ports for a feature."""
    data = load_ports()
    if feature not in data["allocations"]:
        return None
    alloc = data["allocations"][feature]
    return PortAllocation(
        offset=alloc["offset"],
        ports={k: v for k, v in alloc.items() if k != "offset"}
    )


# =============================================================================
# .env Generation
# =============================================================================

def generate_env_content(feature: str, ports: dict[str, int]) -> str:
    """Generate .env file content for a worktree."""
    return f"""# Flovyn Development Environment - Feature: {feature}
# Auto-generated by flovyn-dev. Modify as needed.

# Deployment scenario
SCENARIO=self-hosted

# Application ports (unique for this worktree)
APP_PORT={ports['APP_PORT']}
SERVER_HTTP_PORT={ports['SERVER_HTTP_PORT']}
SERVER_GRPC_PORT={ports['SERVER_GRPC_PORT']}

# App URL (change for remote access)
APP_URL=http://localhost:{ports['APP_PORT']}

# PostgreSQL ports
SERVER_POSTGRES_PORT={ports['SERVER_POSTGRES_PORT']}
APP_POSTGRES_PORT={ports['APP_POSTGRES_PORT']}

# NATS ports
NATS_PORT={ports['NATS_PORT']}
NATS_MONITOR_PORT={ports['NATS_MONITOR_PORT']}

# Jaeger ports
JAEGER_UI_PORT={ports['JAEGER_UI_PORT']}
JAEGER_OTLP_GRPC_PORT={ports['JAEGER_OTLP_GRPC_PORT']}
JAEGER_OTLP_HTTP_PORT={ports['JAEGER_OTLP_HTTP_PORT']}

# Secrets
BETTER_AUTH_SECRET=dev-secret-key-for-worktree-{feature}

# Rust logging
RUST_LOG=info,flovyn_server=debug

# SDK Examples / Workers
FLOVYN_GRPC_SERVER_URL=http://localhost:{ports['SERVER_GRPC_PORT']}
FLOVYN_WORKER_TOKEN=fwt_dev_worker
FLOVYN_ORG_ID=550e8400-e29b-41d4-a716-446655440000
"""


# =============================================================================
# Git/Worktree Operations
# =============================================================================

def run_git(repo_path: Path, *args, check: bool = True, capture: bool = False) -> subprocess.CompletedProcess:
    """Run a git command in the specified repo."""
    cmd = ["git", "-C", str(repo_path)] + list(args)
    return subprocess.run(
        cmd,
        check=check,
        capture_output=capture,
        text=True,
    )


def worktree_exists(feature: str) -> bool:
    """Check if worktree directory exists."""
    return (WORKTREES_DIR / feature).exists()


def get_worktree_repos(feature: str) -> list[str]:
    """Get list of repos that have worktrees for this feature."""
    worktree_path = WORKTREES_DIR / feature
    if not worktree_path.exists():
        return []
    return [r for r in REPOS if (worktree_path / r).exists()]


def list_all_worktrees() -> list[str]:
    """List all feature worktrees."""
    if not WORKTREES_DIR.exists():
        return []
    return sorted([
        d.name for d in WORKTREES_DIR.iterdir()
        if d.is_dir() and not d.name.startswith(".")
    ])


# =============================================================================
# Commands
# =============================================================================

def cmd_create(args: argparse.Namespace) -> int:
    """Create worktrees for a feature."""
    feature = args.feature

    if worktree_exists(feature):
        print(colored(f"Error: Worktree '{feature}' already exists", Colors.RED))
        return 1

    print(colored(f"Creating worktree: {feature}", Colors.BLUE))

    # Allocate ports
    print(colored("  Allocating ports...", Colors.YELLOW))
    allocation = allocate_ports(feature)
    print(f"    Offset: {allocation.offset}")
    for name, port in allocation.ports.items():
        print(f"    {name}: {port}")

    # Create worktree directory
    worktree_path = WORKTREES_DIR / feature
    worktree_path.mkdir(parents=True, exist_ok=True)

    # Create worktrees for each repo
    created_repos = []
    for repo in REPOS:
        repo_path = FLOVYN_ROOT / repo
        if not repo_path.exists():
            print(colored(f"  Skipping {repo} (not found)", Colors.YELLOW))
            continue

        target_path = worktree_path / repo
        print(f"  Creating {repo}...", end=" ")

        try:
            # Create branch if it doesn't exist
            run_git(repo_path, "branch", feature, capture=True, check=False)

            # Create worktree
            run_git(repo_path, "worktree", "add", str(target_path), feature)
            print(colored("✓", Colors.GREEN))
            created_repos.append(repo)
        except subprocess.CalledProcessError as e:
            print(colored(f"✗ {e}", Colors.RED))
            # Continue with other repos

    # Generate .env for dev worktree
    if "dev" in created_repos:
        env_path = worktree_path / "dev" / ".env"
        print(f"  Generating {env_path.relative_to(FLOVYN_ROOT)}...", end=" ")
        env_content = generate_env_content(feature, allocation.ports)
        env_path.write_text(env_content)
        print(colored("✓", Colors.GREEN))

    # Copy untracked files
    for file_path in UNTRACKED_FILES:
        src = FLOVYN_ROOT / file_path
        dst = worktree_path / file_path
        if src.exists():
            print(f"  Copying {file_path}...", end=" ")
            dst.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(src, dst)
            print(colored("✓", Colors.GREEN))

    print()
    print(colored(f"Worktree '{feature}' created successfully!", Colors.GREEN))
    print()
    print("Next steps:")
    print(f"  cd {worktree_path}")
    print(f"  cd dev && mise run start   # Start infrastructure")
    print(f"  mise run server             # Start server (in another terminal)")
    print(f"  mise run app                # Start app (in another terminal)")
    print()
    print("Ports:")
    print(f"  App:         http://localhost:{allocation.ports['APP_PORT']}")
    print(f"  Server HTTP: http://localhost:{allocation.ports['SERVER_HTTP_PORT']}")
    print(f"  Server gRPC: localhost:{allocation.ports['SERVER_GRPC_PORT']}")
    print(f"  Jaeger:      http://localhost:{allocation.ports['JAEGER_UI_PORT']}")

    return 0


def cmd_delete(args: argparse.Namespace) -> int:
    """Delete worktrees for a feature."""
    feature = args.feature

    if not worktree_exists(feature):
        print(colored(f"Error: Worktree '{feature}' does not exist", Colors.RED))
        return 1

    worktree_path = WORKTREES_DIR / feature

    if not args.force:
        # Check for uncommitted changes
        repos_with_changes = []
        for repo in get_worktree_repos(feature):
            result = run_git(worktree_path / repo, "status", "--porcelain", capture=True, check=False)
            if result.stdout.strip():
                repos_with_changes.append(repo)

        if repos_with_changes:
            print(colored("Warning: The following repos have uncommitted changes:", Colors.YELLOW))
            for repo in repos_with_changes:
                print(f"  - {repo}")
            print()
            response = input("Delete anyway? [y/N] ").strip().lower()
            if response != "y":
                print("Cancelled.")
                return 1

    print(colored(f"Deleting worktree: {feature}", Colors.BLUE))

    # Remove worktrees for each repo
    for repo in REPOS:
        repo_path = FLOVYN_ROOT / repo
        target_path = worktree_path / repo

        if not target_path.exists():
            continue

        print(f"  Removing {repo}...", end=" ")
        try:
            run_git(repo_path, "worktree", "remove", str(target_path), "--force" if args.force else None)
            print(colored("✓", Colors.GREEN))
        except subprocess.CalledProcessError:
            # Try to remove manually if git worktree fails
            try:
                shutil.rmtree(target_path)
                run_git(repo_path, "worktree", "prune", check=False)
                print(colored("✓ (manual)", Colors.GREEN))
            except Exception as e:
                print(colored(f"✗ {e}", Colors.RED))

    # Remove worktree directory if empty
    try:
        worktree_path.rmdir()
    except OSError:
        # Not empty, try to remove remaining files
        shutil.rmtree(worktree_path, ignore_errors=True)

    # Delete branches (optional)
    if args.delete_branches:
        print(colored("  Deleting branches...", Colors.YELLOW))
        for repo in REPOS:
            repo_path = FLOVYN_ROOT / repo
            if not repo_path.exists():
                continue
            result = run_git(repo_path, "branch", "-d", feature, capture=True, check=False)
            if result.returncode == 0:
                print(f"    {repo}: branch deleted")

    # Release ports
    print(f"  Releasing ports...", end=" ")
    if release_ports(feature):
        print(colored("✓", Colors.GREEN))
    else:
        print(colored("(not allocated)", Colors.YELLOW))

    print()
    print(colored(f"Worktree '{feature}' deleted.", Colors.GREEN))
    return 0


def cmd_status(args: argparse.Namespace) -> int:
    """Show git status for a feature's worktrees."""
    feature = args.feature

    if not worktree_exists(feature):
        print(colored(f"Error: Worktree '{feature}' does not exist", Colors.RED))
        return 1

    worktree_path = WORKTREES_DIR / feature

    print(colored(f"Status for: {feature}", Colors.BLUE))
    print()

    for repo in get_worktree_repos(feature):
        repo_worktree = worktree_path / repo
        print(colored(f"[{repo}]", Colors.CYAN))

        # Get branch info
        result = run_git(repo_worktree, "branch", "--show-current", capture=True, check=False)
        branch = result.stdout.strip() if result.returncode == 0 else "unknown"

        # Get status
        result = run_git(repo_worktree, "status", "--porcelain", capture=True, check=False)
        status_lines = result.stdout.strip().split("\n") if result.stdout.strip() else []

        # Get ahead/behind
        result = run_git(repo_worktree, "rev-list", "--left-right", "--count", f"origin/{branch}...HEAD", capture=True, check=False)
        if result.returncode == 0:
            parts = result.stdout.strip().split()
            behind, ahead = int(parts[0]), int(parts[1]) if len(parts) > 1 else 0
        else:
            behind, ahead = 0, 0

        # Print summary
        status_text = colored("clean", Colors.GREEN) if not status_lines else colored(f"{len(status_lines)} changes", Colors.YELLOW)
        sync_parts = []
        if ahead:
            sync_parts.append(colored(f"↑{ahead}", Colors.GREEN))
        if behind:
            sync_parts.append(colored(f"↓{behind}", Colors.RED))
        sync_text = " ".join(sync_parts) if sync_parts else "in sync"

        print(f"  Branch: {branch}")
        print(f"  Status: {status_text}")
        print(f"  Remote: {sync_text}")

        if args.verbose and status_lines:
            print("  Changes:")
            for line in status_lines[:10]:
                print(f"    {line}")
            if len(status_lines) > 10:
                print(f"    ... and {len(status_lines) - 10} more")
        print()

    return 0


def cmd_commit(args: argparse.Namespace) -> int:
    """Commit changes across all repos in a worktree."""
    feature = args.feature
    message = args.message

    if not worktree_exists(feature):
        print(colored(f"Error: Worktree '{feature}' does not exist", Colors.RED))
        return 1

    worktree_path = WORKTREES_DIR / feature

    print(colored(f"Committing in: {feature}", Colors.BLUE))
    print(f"Message: {message}")
    print()

    committed = []
    for repo in get_worktree_repos(feature):
        repo_worktree = worktree_path / repo

        # Check for changes
        result = run_git(repo_worktree, "status", "--porcelain", capture=True, check=False)
        if not result.stdout.strip():
            continue

        print(f"  {repo}...", end=" ")

        try:
            # Stage all changes
            run_git(repo_worktree, "add", "-A")

            # Commit
            run_git(repo_worktree, "commit", "-m", message)
            print(colored("✓", Colors.GREEN))
            committed.append(repo)
        except subprocess.CalledProcessError as e:
            print(colored(f"✗ {e}", Colors.RED))

    if committed:
        print()
        print(colored(f"Committed in {len(committed)} repo(s): {', '.join(committed)}", Colors.GREEN))
    else:
        print(colored("No changes to commit.", Colors.YELLOW))

    return 0


def cmd_list(args: argparse.Namespace) -> int:
    """List all worktrees."""
    worktrees = list_all_worktrees()

    if not worktrees:
        print(colored("No worktrees found.", Colors.YELLOW))
        print(f"Create one with: flovyn-dev create <feature>")
        return 0

    print(colored("Worktrees:", Colors.BLUE))
    print()

    ports_data = load_ports()

    for feature in worktrees:
        repos = get_worktree_repos(feature)
        ports = ports_data.get("allocations", {}).get(feature, {})

        print(colored(f"  {feature}", Colors.CYAN))
        print(f"    Repos: {', '.join(repos)}")
        if ports:
            app_port = ports.get("APP_PORT", "?")
            server_port = ports.get("SERVER_HTTP_PORT", "?")
            print(f"    Ports: app={app_port}, server={server_port}")
        print()

    return 0


def cmd_env(args: argparse.Namespace) -> int:
    """Show allocated ports for a feature."""
    feature = args.feature

    allocation = get_ports(feature)

    if not allocation:
        print(colored(f"Error: No ports allocated for '{feature}'", Colors.RED))
        return 1

    print(colored(f"Environment for: {feature}", Colors.BLUE))
    print(f"  Offset: {allocation.offset}")
    print()
    print(colored("Ports:", Colors.CYAN))
    for name, port in sorted(allocation.ports.items()):
        print(f"  {name}={port}")

    print()
    print(colored("URLs:", Colors.CYAN))
    print(f"  App:         http://localhost:{allocation.ports['APP_PORT']}")
    print(f"  Server HTTP: http://localhost:{allocation.ports['SERVER_HTTP_PORT']}")
    print(f"  Server gRPC: localhost:{allocation.ports['SERVER_GRPC_PORT']}")
    print(f"  Jaeger UI:   http://localhost:{allocation.ports['JAEGER_UI_PORT']}")
    print(f"  NATS:        localhost:{allocation.ports['NATS_PORT']}")

    return 0


# =============================================================================
# Main
# =============================================================================

def main() -> int:
    parser = argparse.ArgumentParser(
        description="Flovyn development workflow manager",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  flovyn-dev create webhook-retry   Create worktrees for a new feature
  flovyn-dev list                   List all worktrees
  flovyn-dev status webhook-retry   Show git status
  flovyn-dev commit webhook-retry -m "feat: add retry"
  flovyn-dev env webhook-retry      Show allocated ports
  flovyn-dev delete webhook-retry   Delete worktrees
        """,
    )

    subparsers = parser.add_subparsers(dest="command", required=True)

    # create
    p_create = subparsers.add_parser("create", help="Create worktrees for a feature")
    p_create.add_argument("feature", help="Feature name (used as branch name)")
    p_create.set_defaults(func=cmd_create)

    # delete
    p_delete = subparsers.add_parser("delete", help="Delete worktrees for a feature")
    p_delete.add_argument("feature", help="Feature name")
    p_delete.add_argument("-f", "--force", action="store_true", help="Force delete without confirmation")
    p_delete.add_argument("--delete-branches", action="store_true", help="Also delete git branches")
    p_delete.set_defaults(func=cmd_delete)

    # status
    p_status = subparsers.add_parser("status", help="Show git status for a feature")
    p_status.add_argument("feature", help="Feature name")
    p_status.add_argument("-v", "--verbose", action="store_true", help="Show detailed changes")
    p_status.set_defaults(func=cmd_status)

    # commit
    p_commit = subparsers.add_parser("commit", help="Commit changes across repos")
    p_commit.add_argument("feature", help="Feature name")
    p_commit.add_argument("-m", "--message", required=True, help="Commit message")
    p_commit.set_defaults(func=cmd_commit)

    # list
    p_list = subparsers.add_parser("list", help="List all worktrees")
    p_list.set_defaults(func=cmd_list)

    # env
    p_env = subparsers.add_parser("env", help="Show allocated ports for a feature")
    p_env.add_argument("feature", help="Feature name")
    p_env.set_defaults(func=cmd_env)

    args = parser.parse_args()
    return args.func(args)


if __name__ == "__main__":
    sys.exit(main())
