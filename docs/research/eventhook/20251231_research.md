# Research: Eventhook Plugin for Flovyn

**Date:** 2024-12-29 (Updated: 2024-12-31)
**Status:** Research
**Scope:**
- Part 1: Inbound webhook reception, routing to workflows/tasks/promises
- Part 2: Outbound webhook delivery to external systems
- Part 3: n8n-like workflow automation capabilities
- Part 4: Event bus architecture (EventBridge-like routing)

## Executive Summary

This document researches how to implement **Eventhook**, a comprehensive event and webhook plugin for Flovyn Server. Inspired by Svix, Convoy, n8n, and AWS EventBridge, the plugin provides:

**Part 1: Inbound Webhooks** — Receive webhooks from external providers and route them to:
- Trigger new workflow executions
- Create standalone tasks
- Resolve/reject workflow promises

**Part 2: Outbound Webhooks** — Deliver events to external systems with:
- Endpoint management (URL, authentication, rate limits)
- Delivery tracking and retry with exponential backoff
- Signature generation for receiver verification

**Part 3: n8n-like Automation** — Enable workflow automation patterns:
- HTTP Request task type for making external API calls
- Integration with promise system for async callbacks
- Foundation for visual workflow editor

**Part 4: Event Bus** — Route events to workflows based on rules:
- Developers push events to a single endpoint
- Pattern-based routing to multiple workflows/tasks
- Built-in events from workflow/task lifecycle

The system stores all events and delivery attempts for debugging, replay, and auditing.

**Plugin Name:** `eventhook`
**Table Prefix:** `p_eventhook__`
**API Prefix:** `/api/orgs/{org_slug}/eventhook/` (trusted plugin, no `/p/` segment)

---

# Part 1: Inbound Webhooks

---

## 1. Reference Implementations Analysis

### 1.1 Svix Architecture

Svix is a webhook infrastructure platform with both outbound delivery and inbound reception capabilities.

**Key Components:**

1. **Svix Bridge** (`bridge/svix-bridge/src/webhook_receiver/`)
   - Receives webhooks at `/webhook/:integration_id`
   - Uses pluggable `Verifier` trait for signature validation
   - Supports JavaScript transformations via `TransformerTx`
   - Outputs to configurable `ReceiverOutput` (queue, HTTP, etc.)

2. **Ingest Sources** (`flovyn-server/rust/src/api/ingest_source.rs`)
   - CRUD API for managing webhook endpoints
   - Token rotation with 48-hour grace period
   - Each source generates unique `ingestUrl`

3. **Verification System** (`flovyn-server/bridge/svix-bridge/src/webhook_receiver/verification.rs`)
   ```rust
   #[async_trait]
   pub trait VerificationMethod {
       async fn validate(&self, req: SerializableRequest<Unvalidated>) -> Result<bool>;
   }
   ```
   - Built-in verifiers: `SvixVerifier` (HMAC-SHA256), `NoVerifier`
   - Uses `svix-id`, `svix-signature`, `svix-timestamp` headers

4. **Request Processing Flow** (`webhook_receiver/mod.rs:109-138`)
   ```rust
   async fn route(
       Path(integration_id): Path<IntegrationId>,
       State(InternalState { routes, transformer_tx }): State<InternalState>,
       req: SerializableRequest<Unvalidated>,
   ) -> Result<http::StatusCode, http::StatusCode> {
       // 1. Lookup route by integration_id
       let IntegrationState { verifier, output, transformation } = routes.get(&integration_id)?;

       // 2. Validate signature
       let req = req.validate(verifier).await?;

       // 3. Parse and optionally transform payload
       let payload = parse_payload(req.payload(), transformation, transformer_tx).await?;

       // 4. Forward to output handler
       handle(payload, output).await
   }
   ```

**Key Patterns:**
- Integration ID in URL path for routing
- Async transformation pipeline
- Stateless webhook receiver (forwards to queue/output)
- Token-based URL security with rotation support

### 1.2 Convoy Architecture

Convoy is a comprehensive eventhook plugin written in Go with full inbound and outbound capabilities.

**Key Components:**

1. **Ingest Endpoint** (`api/ingest.go`)
   - Route: `POST /ingest/{maskID}`
   - Validates source by maskID (public URL identifier)
   - Enforces max payload size limits (configurable per project)
   - Verifies webhook signature based on source config
   - Handles idempotency via configurable keys (header/body paths)
   - Extracts payload (JSON, form-encoded, multipart)
   - Creates Event record and queues for async processing
   - Returns immediately with custom response (if configured)

2. **Source Model** (`api/models/source.go`)
   ```go
   type CreateSource struct {
       Name             string                  `json:"name"`
       Type             datastore.SourceType    `json:"type"`    // HTTP, PubSub, DBChangeStream
       Provider         datastore.SourceProvider `json:"provider"` // github, stripe, shopify
       Verifier         VerifierConfig          `json:"verifier"`
       CustomResponse   CustomResponse          `json:"custom_response"`
       IdempotencyKeys  []string                `json:"idempotency_keys"` // e.g., ["header.x-request-id"]
       BodyFunction     *string                 `json:"body_function"`    // JS transformation
       HeaderFunction   *string                 `json:"header_function"`
   }
   ```

3. **Subscription-Based Routing** (`api/handlers/subscription.go`)
   - Routes events from sources to endpoints
   - Filter configuration:
     ```go
     type FilterConfiguration struct {
         EventTypes []string       `json:"event_types"` // with wildcard "*" support
         Filter     struct {
             Headers   map[string]interface{} `json:"headers"`
             Body      map[string]interface{} `json:"body"`
         }
     }
     ```
   - Supports wildcards (`*` for all events)
   - Transformation functions for payload adaptation

4. **Verifier Types** (`datastore/models.go` and `api/models/source.go`)
   ```go
   type VerifierConfig struct {
       Type      VerifierType `json:"type"` // hmac, basic_auth, api_key
       HMac      *HMac        `json:"hmac"`
       BasicAuth *BasicAuth   `json:"basic_auth"`
       ApiKey    *ApiKey      `json:"api_key"`
   }

   type HMac struct {
       Header   string       `json:"header"`   // e.g., "X-Hub-Signature-256"
       Secret   string       `json:"secret"`
       Hash     string       `json:"hash"`     // sha256, sha512
       Encoding EncodingType `json:"encoding"` // hex, base64
   }
   ```
   - Provider-specific implementations: GitHub, Twitter, Shopify, Stripe

5. **Event Storage** (`datastore/models.go`)
   ```go
   type Event struct {
       UID             string            `json:"uid"`
       EventType       string            `json:"event_type"`
       SourceID        string            `json:"source_id"`
       Raw             string            `json:"raw"`        // Original payload
       Data            []byte            `json:"data"`       // Parsed payload
       Headers         map[string]string `json:"headers"`
       URLQueryParams  string            `json:"url_query_params"`
       IdempotencyKey  string            `json:"idempotency_key"`
       IsDuplicateEvent bool             `json:"is_duplicate_event"`
       Status          EventStatus       `json:"status"`
       AcknowledgedAt  time.Time         `json:"acknowledged_at"`
   }
   ```

6. **Event Delivery Tracking** (`datastore/models.go`)
   - Tracks each delivery attempt with full HTTP details
   - Supports retry strategies (linear/exponential backoff)
   - Records request/response for debugging

**Key Patterns:**
- **MaskID pattern**: Separates public URL identifier from internal UUID
- **Idempotency keys**: Configurable extraction from header/body fields
  - Format: `request.header.x-request-id` or `request.body.event_id`
- **JavaScript transformations**: Payload mutation via JS functions
- **Subscription rules**: Flexible routing with filters on event type, headers, body
- **Queue-first architecture**: Returns immediately, processes async

### 1.3 Comparison Summary

| Feature | Svix | Convoy |
|---------|------|--------|
| Language | Rust | Go |
| URL Pattern | `/webhook/{integration_id}` | `/ingest/{maskID}` |
| Verification | Trait-based (SvixVerifier, NoVerifier) | Config-based (HMAC, BasicAuth, APIKey, Providers) |
| Transformations | JavaScript via external service | Inline JavaScript functions |
| Routing | Single output per integration | Subscription-based with filters |
| Storage | Delegates to output handler | Full event storage with delivery tracking |
| Idempotency | Header-based | Configurable header/body paths |

---

## 2. Flovyn Integration Points

### 2.1 Current Flovyn Architecture

**Entry Points for Webhook Actions:**

| Action | Current API | Method |
|--------|-------------|--------|
| Trigger Workflow | `POST /api/orgs/{slug}/workflow-executions` | REST |
| Trigger Workflow | `WorkflowDispatch.StartWorkflow` | gRPC |
| Create Task | `POST /api/orgs/{slug}/task-executions` | REST |
| Create Task | `TaskExecution.SubmitTask` | gRPC |
| Resolve Promise | `WorkflowDispatch.ResolvePromise` | gRPC only |
| Reject Promise | `WorkflowDispatch.RejectPromise` | gRPC only |

**Current Authentication:**
- JWT tokens with org claims (`flovyn-server/server/src/api/rest/middleware.rs`)
- Worker tokens with embedded org ID
- Authorization checks via `state.authorize(principal)`

**Promise System:**
- Promises created by workflows with unique IDs or names
- Resolution via gRPC only (no REST endpoint currently)
- Supports both ID-based and name-based lookup
- Schema: `promise` table with `id`, `workflow_execution_id`, `name`, `resolved`, `value`, `error`

### 2.2 Required Extensions

1. **REST endpoint for promise resolution** - Currently gRPC only
2. **Webhook source management** - New entity type
3. **Webhook event storage** - Audit and debugging
4. **Routing rules** - Connect sources to actions

---

## 3. Plugin Architecture

The eventhook plugin will be implemented as a Flovyn Server plugin following the conventions in `flovyn-server/plugins/README.md`.

### 3.1 Directory Structure

```
plugins/
└── eventhook/
    ├── Cargo.toml
    ├── migrations/
    │   └── 20250101000001_init.sql
    └── src/
        ├── lib.rs              # Plugin trait implementation
        ├── api/
        │   ├── mod.rs
        │   ├── sources.rs      # Source CRUD handlers
        │   ├── routes.rs       # Route CRUD handlers
        │   ├── events.rs       # Event query/replay handlers
        │   └── ingest.rs       # Webhook reception endpoint
        ├── domain/
        │   ├── mod.rs
        │   ├── source.rs       # WebhookSource entity
        │   ├── route.rs        # WebhookRoute entity
        │   └── event.rs        # WebhookEvent entity
        ├── repository/
        │   ├── mod.rs
        │   ├── source_repository.rs
        │   ├── route_repository.rs
        │   └── event_repository.rs
        ├── service/
        │   ├── mod.rs
        │   ├── ingest_service.rs    # Webhook reception logic
        │   ├── processor_service.rs # Event processing logic
        │   └── verifier.rs          # Signature verification
        └── processor.rs        # Background event processor
```

### 3.2 Plugin Implementation

```rust
// plugins/eventhook/src/lib.rs

pub struct EventhookPlugin;

impl EventhookPlugin {
    pub const NAME: &'static str = "eventhook";
    pub const VERSION: &'static str = "0.1.0";

    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl Plugin for EventhookPlugin {
    fn name(&self) -> &'static str {
        Self::NAME
    }

    fn version(&self) -> &'static str {
        Self::VERSION
    }

    fn trusted(&self) -> bool {
        true // First-party plugin
    }

    fn migrations(&self) -> Vec<PluginMigration> {
        flovyn_plugin::plugin_migrations!()
    }

    fn rest_routes(&self, services: Arc<PluginServices>) -> Router {
        api::create_router(services)
    }

    fn openapi(&self) -> Option<utoipa::openapi::OpenApi> {
        Some(WebhooksApiDoc::openapi())
    }

    async fn on_startup(&self, services: Arc<PluginServices>) -> Result<(), PluginError> {
        // Start background event processor
        let processor = EventProcessor::new(services.clone());
        tokio::spawn(processor.run());
        Ok(())
    }
}
```

### 3.3 API Routes

As a **trusted plugin** (`trusted() = true`), routes are mounted at `/api/orgs/{org_slug}/eventhook/` (without the `/p/` segment).

**Management Routes:**
- `GET /api/orgs/{org_slug}/eventhook/sources` - List sources
- `POST /api/orgs/{org_slug}/eventhook/sources` - Create source
- `GET /api/orgs/{org_slug}/eventhook/sources/{source_slug}` - Get source
- `PUT /api/orgs/{org_slug}/eventhook/sources/{source_slug}` - Update source
- `DELETE /api/orgs/{org_slug}/eventhook/sources/{source_slug}` - Delete source
- `GET /api/orgs/{org_slug}/eventhook/sources/{source_slug}/routes` - List routes
- `POST /api/orgs/{org_slug}/eventhook/sources/{source_slug}/routes` - Create route
- `GET /api/orgs/{org_slug}/eventhook/events` - List events
- `GET /api/orgs/{org_slug}/eventhook/events/{id}` - Get event details
- `POST /api/orgs/{org_slug}/eventhook/events/{id}/replay` - Replay event

**Ingest Routes** (for external providers to send webhooks):
- `POST /api/orgs/{org_slug}/eventhook/in/{source_slug}` - Receive webhooks
- `GET /api/orgs/{org_slug}/eventhook/in/{source_slug}` - Handle verification challenges (e.g., Slack)

Example webhook URL: `https://api.example.com/api/orgs/acme-corp/eventhook/in/github`

**Note:** The `trusted()` flag removes only the `/p/` segment, not the entire plugin namespace. Routes still follow the convention of `/api/orgs/{org_slug}/<plugin-name>/...`.

### 3.4 Authentication for Ingest Endpoints

The ingest endpoints (`/in/{source_slug}`) require special handling because external webhook providers (GitHub, Stripe, etc.) cannot use Flovyn's JWT or worker tokens.

**Key Insight**: Instead of building a separate verification system, **integrate with Flovyn's existing `Authenticator` trait**. This aligns with the pluggable auth architecture documented in `.dev/docs/design/20251224_support-different-auth-scenarios.md`.

**Authentication Strategy:**

| Layer | Purpose | Mechanism |
|-------|---------|-----------|
| **URL Obscurity** | First barrier | Org slug + source slug must be known |
| **WebhookSourceAuthenticator** | Primary auth | Implements `Authenticator` trait with HMAC/API key |
| **IP Allowlisting** | Optional | Restrict to known provider IPs |
| **Rate Limiting** | Abuse prevention | Per-source or per-org limits |

**Implementation Approach:**

#### Step 1: Extend `AuthRequest` to Include Body

The current `AuthRequest` (in `flovyn-server/crates/core/src/auth/request.rs`) doesn't include the request body, which is required for HMAC signature verification. Add an optional body field:

```rust
// crates/core/src/auth/request.rs
#[derive(Debug, Clone)]
pub struct AuthRequest {
    pub headers: HashMap<String, String>,
    pub query: HashMap<String, String>,
    pub client_ip: Option<IpAddr>,
    pub protocol: Protocol,
    /// Request body (for signature verification)
    pub body: Option<Vec<u8>>,  // NEW
}

impl AuthRequest {
    /// Builder pattern: set body for webhook signature verification
    pub fn with_body(mut self, body: Vec<u8>) -> Self {
        self.body = Some(body);
        self
    }
}
```

#### Step 2: Use `Service` Principal Type for Webhook Sources

Webhook sources use the existing `Service` principal type (no schema changes needed). The source is identified by its `principal_id`:

```rust
// When webhook is authenticated, principal uses Service type
impl Principal {
    pub fn webhook_source(org_id: Uuid, source_id: Uuid, source_slug: &str) -> Self {
        // Use Service principal type with "webhook:" prefix for identification
        Self::new(PrincipalType::Service, format!("webhook:{}", source_id))
            .with_org_id(org_id)
            .with_attr("source_id", source_id.to_string())
            .with_attr("source_slug", source_slug.to_string())
    }
}
```

This approach:
- **No schema changes**: Uses existing `PrincipalType::Service`
- **Clear identification**: `principal_id` prefix `webhook:` distinguishes from other services
- **Rich context**: Attributes carry source details for logging/auditing

#### Step 3: Implement `WebhookSourceAuthenticator`

This authenticator validates webhook signatures and returns a `Principal` representing the webhook source:

```rust
// plugins/eventhook/src/auth/webhook_source_authenticator.rs
use flovyn_core::auth::{AuthError, AuthRequest, Authenticator, Principal};

pub struct WebhookSourceAuthenticator {
    source_repository: Arc<WebhookSourceRepository>,
}

#[async_trait]
impl Authenticator for WebhookSourceAuthenticator {
    async fn authenticate(&self, request: &AuthRequest) -> Result<Principal, AuthError> {
        // 1. Extract org_slug and source_slug from path (stored in headers/query by middleware)
        let org_slug = request.query.get("_org_slug")
            .ok_or(AuthError::NoCredentials)?;
        let source_slug = request.query.get("_source_slug")
            .ok_or(AuthError::NoCredentials)?;

        // 2. Lookup source from database
        let source = self.source_repository
            .find_by_slug(org_slug, source_slug)
            .await
            .map_err(|_| AuthError::InvalidCredentials("Source not found".into()))?;

        // 3. Verify signature based on source's verifier config
        let body = request.body.as_ref()
            .ok_or(AuthError::InvalidCredentials("Body required for verification".into()))?;

        match &source.verifier_type {
            VerifierType::Hmac(config) => {
                self.verify_hmac(&request.headers, body, config)?;
            }
            VerifierType::ApiKey(config) => {
                self.verify_api_key(&request.headers, &request.query, config)?;
            }
            VerifierType::BasicAuth(config) => {
                self.verify_basic_auth(&request.headers, config)?;
            }
            VerifierType::None => {
                // No verification required
            }
        }

        // 4. Return Principal representing the authenticated webhook source
        Ok(Principal::webhook_source(source.org_id, source.id, &source.slug))
    }

    fn name(&self) -> &'static str {
        "webhook_source"
    }
}

impl WebhookSourceAuthenticator {
    fn verify_hmac(
        &self,
        headers: &HashMap<String, String>,
        body: &[u8],
        config: &HmacConfig,
    ) -> Result<(), AuthError> {
        // Get signature from header
        let sig_header = headers.get(&config.header.to_lowercase())
            .ok_or(AuthError::InvalidCredentials("Missing signature header".into()))?;

        // Strip prefix if configured (e.g., "sha256=" for GitHub)
        let signature = match &config.prefix {
            Some(prefix) => sig_header.strip_prefix(prefix)
                .ok_or(AuthError::InvalidCredentials("Invalid signature prefix".into()))?,
            None => sig_header.as_str(),
        };

        // Decode signature
        let expected = match config.encoding {
            Encoding::Hex => hex::decode(signature)
                .map_err(|_| AuthError::InvalidCredentials("Invalid hex signature".into()))?,
            Encoding::Base64 => base64::decode(signature)
                .map_err(|_| AuthError::InvalidCredentials("Invalid base64 signature".into()))?,
        };

        // Compute HMAC
        let computed = compute_hmac(&config.secret, body, config.algorithm);

        // Constant-time comparison
        if !constant_time_eq(&computed, &expected) {
            return Err(AuthError::InvalidCredentials("Invalid signature".into()));
        }

        Ok(())
    }
}
```

#### Step 4: Plugin Handles Its Own Authentication

Plugin routes are merged **without** the core auth middleware (see `server/src/api/rest/mod.rs:202-203`). This means the Eventhook plugin handles authentication directly:

```rust
// plugins/eventhook/src/api/ingest.rs

/// Ingest endpoint - verifies webhook signature in handler
pub async fn receive_webhook(
    State(state): State<EventhookState>,
    Path((org_slug, source_slug)): Path<(String, String)>,
    headers: HeaderMap,
    body: Bytes,
) -> Result<StatusCode, EventhookError> {
    // 1. Look up org
    let org = state.org_repo.find_by_slug(&org_slug).await?
        .ok_or(EventhookError::OrgNotFound)?;

    // 2. Look up webhook source
    let source = state.source_repo.find_by_slug(org.id, &source_slug).await?
        .ok_or(EventhookError::SourceNotFound)?;

    // 3. Verify signature (if configured)
    if let Some(ref verifier) = source.signature_verifier {
        verifier.verify(&headers, &body)?;
    }

    // 4. Parse and route the event
    let event = FlovynEvent::from_webhook(&source, &body)?;
    state.event_publisher.publish(&event).await?;

    Ok(StatusCode::OK)
}
```

**Why handle auth in the handler?**

1. **No core changes needed** - plugin routes bypass core auth middleware
2. **Authentication is sufficient** - signature verification validates the webhook
3. **Authorization is implicit** - if a source is configured, it's authorized to receive webhooks
4. **Action-level authorization happens separately** - when triggering workflows/tasks, those operations can go through normal Cedar policy evaluation

#### Step 5: Authorization for Webhook Sources

Add Cedar policies for webhook sources (Service principals with `webhook:` prefix):

```cedar
// Service principals (including webhook sources) can create workflow executions
permit(
    principal is Flovyn::Service,
    action in [
        Flovyn::Action::"create",
        Flovyn::Action::"update"
    ],
    resource is Flovyn::WorkflowExecution
)
when {
    principal.orgId == resource.orgId
};

// Service principals can create task executions
permit(
    principal is Flovyn::Service,
    action == Flovyn::Action::"create",
    resource is Flovyn::TaskExecution
)
when {
    principal.orgId == resource.orgId
};

// Optionally, restrict to only webhook sources using principal_id prefix
permit(
    principal is Flovyn::Service,
    action == Flovyn::Action::"create",
    resource is Flovyn::WorkflowExecution
)
when {
    principal.orgId == resource.orgId &&
    principal.id like "webhook:*"  // Only webhook sources
};
```

**Security Considerations:**

- **Verification secrets** must be stored encrypted (use Flovyn's secret management)
- **Failed verification attempts** should be logged for security monitoring
- **Rate limiting** prevents brute-force attempts on source URLs
- **Source slugs** should be non-guessable (use UUIDs or random tokens if needed)

**Alternative: Token-in-URL Pattern**

For sources that don't support signature verification, add a token to the URL:

```
/api/orgs/{org_slug}/eventhook/in/{source_slug}?token=xxx
```

The token would be:
- Generated per source (like an API key)
- Rotatable with grace period
- Validated by `WebhookSourceAuthenticator`

### 3.5 Authentication for Management Endpoints

Management endpoints (`/sources`, `/routes`, `/events`) use **standard Flovyn authentication** via the default HTTP authenticators configured in `security.endpoints.http.authenticators`:

- JWT tokens (user identity)
- Session tokens (user identity)
- Static API keys (if configured)

No special configuration needed - these endpoints inherit the default auth stack.

**Authorization** uses Cedar policies with role-based access:

```cedar
// Members can view webhook sources and events
permit(
    principal,
    action == Flovyn::Action::"view",
    resource in [Flovyn::WebhookSource, Flovyn::WebhookEvent, Flovyn::WebhookRoute]
)
when {
    principal.orgId == resource.orgId &&
    principal.role in ["OWNER", "ADMIN", "MEMBER"]
};

// Admins can create/update/delete webhook sources and routes
permit(
    principal,
    action in [Flovyn::Action::"create", Flovyn::Action::"update", Flovyn::Action::"delete"],
    resource in [Flovyn::WebhookSource, Flovyn::WebhookRoute]
)
when {
    principal.orgId == resource.orgId &&
    principal.role in ["OWNER", "ADMIN"]
};

// Admins can replay events
permit(
    principal,
    action == Flovyn::Action::"update",
    resource is Flovyn::WebhookEvent
)
when {
    principal.orgId == resource.orgId &&
    principal.role in ["OWNER", "ADMIN"]
};
```

### 3.6 Summary: Auth Integration

The eventhook plugin integrates cleanly with Flovyn's existing auth system:

| Endpoint Type | Authenticator | Authorizer | Principal |
|---------------|---------------|------------|-----------|
| **Ingest** (`/in/*`) | `WebhookSourceAuthenticator` | `Noop` | `Service` (id: `webhook:{source_id}`) |
| **Management** (`/sources`, etc.) | Default HTTP (JWT, Session) | Cedar | `User` |
| **Triggered Actions** | N/A (internal) | Cedar | `Service` (from ingest) |

**Key Benefits:**
- **No core changes needed**: Plugin routes bypass core auth middleware, so auth is handled in-plugin
- **Audit trail**: `Service` principal with `webhook:` prefix links actions to specific sources
- **Policy-based**: Cedar policies control what webhook sources can do
- **No schema changes**: Uses existing `PrincipalType::Service`
- **Self-contained**: All auth logic lives within the Eventhook plugin

### 3.8 Integration with Core Services

The plugin needs access to core Flovyn services for executing actions:

```rust
pub struct WebhooksState {
    pub db_pool: PgPool,
    // Access to core repositories for triggering workflows/tasks
    pub workflow_repository: Arc<WorkflowRepository>,
    pub task_repository: Arc<TaskRepository>,
    pub promise_repository: Arc<PromiseRepository>,
    // Worker notifier for signaling new work
    pub worker_notifier: Arc<WorkerNotifier>,
}
```

This requires extending `PluginServices` or using dependency injection to provide core service access to plugins.

### 3.5 Feature Flag

```toml
# server/Cargo.toml
[features]
default = ["plugin-worker-token"]
plugin-eventhook = ["dep:flovyn-plugin-eventhook"]
all-plugins = ["plugin-worker-token", "plugin-eventhook"]

[dependencies]
flovyn-plugin-eventhook = { workspace = true, optional = true }
```

---

## 4. Proposed Data Model

### 4.1 Core Entities

Following the plugin table naming convention: `p_<plugin_name>__<table_name>`

#### WebhookSource
```sql
CREATE TABLE p_eventhook__source (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES organization(id),

    -- Identification
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(255) NOT NULL,  -- Used in URL path (e.g., "github-main")

    -- Status
    is_enabled BOOLEAN NOT NULL DEFAULT true,

    -- Verification
    verifier_type VARCHAR(50),  -- 'hmac', 'basic_auth', 'api_key', 'none'
    verifier_config JSONB,      -- Type-specific config (secret stored encrypted)

    -- Provider template (optional, for pre-configured verification)
    provider VARCHAR(50),       -- 'github', 'stripe', 'shopify', etc.

    -- Custom response (returned to webhook sender)
    custom_response_body TEXT,
    custom_response_content_type VARCHAR(100),

    -- Idempotency configuration
    idempotency_keys TEXT[],    -- e.g., ['header.x-request-id', 'body.event_id']

    -- Transformation (optional JavaScript functions)
    body_transform_function TEXT,
    header_transform_function TEXT,

    -- Metadata
    description TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted_at TIMESTAMPTZ,

    UNIQUE(org_id, slug) WHERE deleted_at IS NULL
);

CREATE INDEX idx_p_eventhook__source_lookup
    ON p_eventhook__source(org_id, slug)
    WHERE deleted_at IS NULL AND is_enabled = true;
```

#### WebhookRoute
```sql
CREATE TABLE p_eventhook__route (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    source_id UUID NOT NULL REFERENCES p_eventhook__source(id) ON DELETE CASCADE,
    org_id UUID NOT NULL REFERENCES organization(id),

    -- Identification
    name VARCHAR(255) NOT NULL,
    priority INT NOT NULL DEFAULT 0,  -- Higher = evaluated first
    is_enabled BOOLEAN NOT NULL DEFAULT true,

    -- Action type
    action_type VARCHAR(50) NOT NULL,  -- 'trigger_workflow', 'create_task', 'resolve_promise'

    -- Action configuration (JSON schema varies by action_type)
    action_config JSONB NOT NULL,

    -- Filtering (optional - if none specified, matches all events)
    filter_event_types TEXT[],          -- Match specific event types (extracted from payload)
    filter_headers JSONB,               -- Header matching rules
    filter_body JSONB,                  -- Body matching rules (JMESPath/JSONPath)
    filter_function TEXT,               -- JavaScript filter function

    -- Transformation (optional)
    input_transform_function TEXT,      -- JavaScript to transform payload to action input

    -- Metadata
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_p_eventhook__route_source
    ON p_eventhook__route(source_id, priority DESC)
    WHERE is_enabled = true;
```

#### WebhookEvent
```sql
CREATE TABLE p_eventhook__event (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES organization(id),
    source_id UUID NOT NULL REFERENCES p_eventhook__source(id),

    -- Request details
    event_type VARCHAR(255),            -- Extracted or inferred from payload
    raw_payload BYTEA NOT NULL,         -- Original payload bytes
    parsed_payload JSONB,               -- Parsed JSON (if applicable)
    headers JSONB NOT NULL,             -- Request headers (sanitized)
    query_params JSONB,                 -- Query parameters
    content_type VARCHAR(255),

    -- Idempotency
    idempotency_key VARCHAR(512),
    is_duplicate BOOLEAN NOT NULL DEFAULT false,

    -- Processing status
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    -- 'pending', 'processing', 'completed', 'failed', 'duplicate', 'rejected'

    -- Verification
    verified BOOLEAN,
    verification_error TEXT,

    -- Metadata
    received_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    processed_at TIMESTAMPTZ,

    -- Source IP (for audit/rate-limiting)
    source_ip INET
);

CREATE INDEX idx_p_eventhook__event_org_time
    ON p_eventhook__event(org_id, received_at DESC);
CREATE INDEX idx_p_eventhook__event_source_time
    ON p_eventhook__event(source_id, received_at DESC);
CREATE INDEX idx_p_eventhook__event_idempotency
    ON p_eventhook__event(source_id, idempotency_key)
    WHERE idempotency_key IS NOT NULL;
CREATE INDEX idx_p_eventhook__event_status
    ON p_eventhook__event(org_id, status, received_at DESC)
    WHERE status IN ('pending', 'failed');
```

#### WebhookEventAction
```sql
CREATE TABLE p_eventhook__event_action (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id UUID NOT NULL REFERENCES p_eventhook__event(id) ON DELETE CASCADE,
    route_id UUID NOT NULL REFERENCES p_eventhook__route(id),

    -- Action details
    action_type VARCHAR(50) NOT NULL,

    -- Result
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    -- 'pending', 'success', 'failed', 'skipped'

    -- Links to created resources (mutually exclusive)
    workflow_execution_id UUID REFERENCES workflow_execution(id),
    task_execution_id UUID REFERENCES task_execution(id),
    promise_id VARCHAR(255),

    -- Error tracking
    error_message TEXT,
    error_details JSONB,

    -- Input/output for debugging
    computed_input JSONB,

    -- Timing
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ
);

CREATE INDEX idx_p_eventhook__event_action_event
    ON p_eventhook__event_action(event_id);
CREATE INDEX idx_p_eventhook__event_action_workflow
    ON p_eventhook__event_action(workflow_execution_id)
    WHERE workflow_execution_id IS NOT NULL;
CREATE INDEX idx_p_eventhook__event_action_task
    ON p_eventhook__event_action(task_execution_id)
    WHERE task_execution_id IS NOT NULL;
```

### 4.2 Configuration Schemas

#### Verifier Configuration
```json
{
  "hmac": {
    "header": "X-Hub-Signature-256",
    "secret": "whsec_...",
    "algorithm": "sha256",
    "encoding": "hex",
    "prefix": "sha256="
  }
}
```

```json
{
  "basic_auth": {
    "username": "webhook",
    "password": "secret"
  }
}
```

```json
{
  "api_key": {
    "header": "X-API-Key",
    "value": "sk_..."
  }
}
```

#### Action Configuration Schemas

**trigger_workflow:**
```json
{
  "workflow_kind": "process-payment",
  "queue": "default",
  "priority_seconds": 0,
  "idempotency_key_path": "body.event_id",
  "input_mapping": {
    "type": "jmespath",
    "expression": "{ payment_id: body.data.id, amount: body.data.amount }"
  }
}
```

**create_task:**
```json
{
  "task_kind": "send-notification",
  "queue": "notifications",
  "max_retries": 3,
  "input_mapping": {
    "type": "passthrough"
  }
}
```

**resolve_promise:**
```json
{
  "promise_lookup": {
    "type": "path",
    "path": "body.metadata.promise_id"
  },
  "value_mapping": {
    "type": "jmespath",
    "expression": "body.data"
  }
}
```

---

## 5. API Design

### 5.1 Webhook Sources API

```
# Source management
POST   /api/orgs/{slug}/eventhook/sources
GET    /api/orgs/{slug}/eventhook/sources
GET    /api/orgs/{slug}/eventhook/sources/{source_slug}
PUT    /api/orgs/{slug}/eventhook/sources/{source_slug}
DELETE /api/orgs/{slug}/eventhook/sources/{source_slug}

# Regenerate webhook URL token (optional security feature)
POST   /api/orgs/{slug}/eventhook/sources/{source_slug}/rotate-token

# Test verification config with sample payload
POST   /api/orgs/{slug}/eventhook/sources/{source_slug}/test
```

### 5.2 Webhook Routes API

```
# Route management (nested under sources)
POST   /api/orgs/{slug}/eventhook/sources/{source_slug}/routes
GET    /api/orgs/{slug}/eventhook/sources/{source_slug}/routes
GET    /api/orgs/{slug}/eventhook/sources/{source_slug}/routes/{route_id}
PUT    /api/orgs/{slug}/eventhook/sources/{source_slug}/routes/{route_id}
DELETE /api/orgs/{slug}/eventhook/sources/{source_slug}/routes/{route_id}

# Reorder routes (update priorities)
PUT    /api/orgs/{slug}/eventhook/sources/{source_slug}/routes/reorder
```

### 5.3 Webhook Events API

```
# Event viewing and management
GET    /api/orgs/{slug}/eventhook/events
GET    /api/orgs/{slug}/eventhook/events/{event_id}
GET    /api/orgs/{slug}/eventhook/events/{event_id}/actions
GET    /api/orgs/{slug}/eventhook/events/{event_id}/payload  # Raw payload

# Event operations
POST   /api/orgs/{slug}/eventhook/events/{event_id}/replay
```

### 5.4 Ingest Endpoint (Public)

```
# Primary webhook reception endpoint
POST   /api/orgs/{org_slug}/eventhook/in/{source_slug}
PUT    /api/orgs/{org_slug}/eventhook/in/{source_slug}

# All HTTP methods supported (some webhooks use GET for verification challenges)
GET    /api/orgs/{org_slug}/eventhook/in/{source_slug}
```

### 5.5 Promise Resolution API (Core Server Prerequisite)

These endpoints should be added to the **core Flovyn server** (not the plugin):

```
POST   /api/orgs/{slug}/promises/{promise_id}/resolve
POST   /api/orgs/{slug}/promises/{promise_id}/reject
```

The eventhook plugin plugin will use these endpoints internally when executing promise-related actions.

### 5.6 Response Formats

**Ingest Success Response (default):**
```json
{
  "acknowledged": true,
  "event_id": "evt_550e8400-e29b-41d4-a716-446655440000"
}
```

**Custom Response (if configured on source):**
Returns configured body and content-type verbatim.

**Verification Challenge (e.g., Slack):**
For providers that require verification challenges (returning a challenge value), the ingest endpoint should detect and respond appropriately.

---

## 6. Processing Flow

### 6.1 Webhook Reception Flow

```
1. HTTP POST /api/orgs/{org_slug}/eventhook/in/{source_slug}
   │
2. Lookup org by slug
   │ └── 404 if not found
   │
3. Lookup source by (org_id, source_slug)
   │ └── 404 if not found or disabled
   │
4. Store raw event immediately (for durability)
   │ └── Generate event_id
   │
5. Verify signature (if verifier configured)
   │ ├── Update event.verified = true/false
   │ └── 401 if verification fails (configurable behavior)
   │
6. Check idempotency (if idempotency_keys configured)
   │ ├── Extract key from headers/body
   │ ├── Check for existing event with same key
   │ ├── If duplicate: mark event, return success
   │ └── Store idempotency key
   │
7. Parse payload
   │ ├── JSON, form-encoded, multipart
   │ └── Store parsed_payload
   │
8. Apply transformations (if configured)
   │ ├── body_transform_function
   │ └── header_transform_function
   │
9. Return success response immediately (async processing)
   │ └── Custom response if configured
   │
10. Queue event for processing (NATS or internal queue)
```

### 6.2 Event Processing Flow

```
1. Dequeue webhook event
   │
2. Update event status = 'processing'
   │
3. Load routes for source (ordered by priority DESC)
   │
4. For each route (multiple routes can match):
   │ ├── Evaluate filters
   │ │   ├── Event type match (if filter_event_types set)
   │ │   ├── Header match (if filter_headers set)
   │ │   ├── Body match (if filter_body set, using JMESPath)
   │ │   └── Filter function (if filter_function set)
   │ │
   │ ├── If filters match:
   │ │   ├── Create webhook_event_action record (status='pending')
   │ │   ├── Transform input (if input_transform_function set)
   │ │   │
   │ │   ├── Execute action:
   │ │   │   ├── trigger_workflow:
   │ │   │   │   └── WorkflowRepository.create_with_input(kind, input, idempotency_key)
   │ │   │   ├── create_task:
   │ │   │   │   └── TaskRepository.create(kind, input, queue)
   │ │   │   └── resolve_promise:
   │ │   │       └── PromiseRepository.resolve(promise_id, value)
   │ │   │
   │ │   └── Update action record (status, workflow/task id, timing)
   │ │
   │ └── Continue to next route
   │
5. Update event status based on action results:
   │ ├── All actions succeeded → 'completed'
   │ ├── Some actions failed → 'completed' (with failed actions logged)
   │ └── All actions failed → 'failed'
```

### 6.3 Error Handling

| Error | HTTP Response | Event Storage | Behavior |
|-------|--------------|---------------|----------|
| Org not found | 404 | No | Immediate rejection |
| Source not found | 404 | No | Immediate rejection |
| Source disabled | 404 | No | Immediate rejection |
| Verification failed | 401 or 200* | Yes (`verified=false`) | Configurable (reject or accept) |
| Payload parse error | 400 | Yes (`status='failed'`) | Event stored for debugging |
| Route filter error | N/A | Yes | Log error, continue to next route |
| Action execution error | N/A | Yes (in action) | Record in action, continue processing |
| All actions failed | N/A | Yes (`status='failed'`) | Event marked as failed |

*Some providers expect 200 OK even on verification failure to avoid retries.

---

## 7. Verification System

Webhook verification is implemented as part of `WebhookSourceAuthenticator` (see Section 3.4), which implements the standard `Authenticator` trait. This section documents the verification strategies supported.

### 7.1 Verification Types

The `WebhookSourceAuthenticator` supports multiple verification strategies, configured per webhook source:

| Type | Use Case | Configuration |
|------|----------|---------------|
| `hmac` | Signature-based (GitHub, Stripe, Shopify) | Header name, secret, algorithm, encoding, prefix |
| `basic_auth` | Simple auth | Username, password |
| `api_key` | Token-based | Header name, expected value |
| `none` | Trusted sources | No verification |

### 7.2 HMAC Verification (Primary)

Most webhook providers use HMAC signatures. Configuration options:

```rust
pub struct HmacConfig {
    /// Header containing the signature (e.g., "X-Hub-Signature-256")
    pub header: String,
    /// Secret key for HMAC computation
    pub secret: SecretString,
    /// Hash algorithm (sha256, sha512, sha1)
    pub algorithm: HmacAlgorithm,
    /// Signature encoding (hex, base64)
    pub encoding: Encoding,
    /// Optional prefix to strip (e.g., "sha256=" for GitHub)
    pub prefix: Option<String>,
    /// Optional timestamp validation (for Stripe-style signatures)
    pub timestamp_validation: Option<TimestampConfig>,
}
```

### 7.3 Provider Templates

Pre-configured verifier settings for common webhook providers:

| Provider | Verifier | Header | Algorithm | Encoding | Notes |
|----------|----------|--------|-----------|----------|-------|
| GitHub | HMAC | X-Hub-Signature-256 | SHA256 | hex | Prefix: `sha256=` |
| Stripe | HMAC | Stripe-Signature | SHA256 | hex | Includes timestamp |
| Shopify | HMAC | X-Shopify-Hmac-Sha256 | SHA256 | base64 | |
| Slack | HMAC | X-Slack-Signature | SHA256 | hex | Prefix: `v0=`, timestamp validation |
| Twilio | HMAC | X-Twilio-Signature | SHA1 | base64 | URL included in signature |
| Linear | HMAC | Linear-Signature | SHA256 | hex | |

### 7.4 HMAC Verification Implementation

HMAC verification is implemented as an internal method of `WebhookSourceAuthenticator` (see Section 3.4, Step 3). The full implementation is shown there.

**Key implementation details:**
1. Extract signature from configured header
2. Strip prefix if configured (e.g., `sha256=` for GitHub)
3. Decode signature (hex or base64)
4. Compute HMAC over request body
5. Constant-time comparison to prevent timing attacks

**Note:** There is no separate `WebhookVerifier` trait. Verification is part of the `Authenticator` implementation, which returns `AuthError::InvalidCredentials` on verification failure.

---

## 8. Transformation and Mapping System

### 8.1 Input Mapping Options

| Type | Description | Use Case |
|------|-------------|----------|
| `passthrough` | Raw payload as input | When workflow/task expects full webhook payload |
| `jmespath` | JMESPath query expression | Extracting and restructuring JSON |
| `jsonpath` | JSONPath expression | Alternative syntax (more familiar to some) |
| `javascript` | Custom JavaScript function | Complex transformations |

### 8.2 JMESPath Examples

**Extract nested data:**
```json
{
  "type": "jmespath",
  "expression": "{ order_id: data.object.id, amount: data.object.amount }"
}
```

**With conditionals:**
```json
{
  "type": "jmespath",
  "expression": "{ status: data.object.status, refunded: data.object.refunded || `false` }"
}
```

### 8.3 JavaScript Sandbox

Flovyn already has QuickJS integration via the `flovyn-auth-script` crate (using `rquickjs`). This infrastructure can be reused for webhook transformations.

**Existing infrastructure** (see `flovyn-server/crates/auth-script/README.md`):
- ES2020 JavaScript support
- Sandboxed execution (no filesystem/network access)
- Fast startup (<300μs)
- CLI tool for testing scripts (`verify-script`)

**Webhook transformation adapter:**

```rust
// plugins/eventhook/src/transform/script_transformer.rs
use flovyn_auth_script::ScriptAttributeResolver;  // Reuse core JS engine

pub struct ScriptTransformer {
    script: String,
    // Reuse the same rquickjs infrastructure
}

impl ScriptTransformer {
    pub fn transform(&self, event: &WebhookEvent) -> Result<serde_json::Value, TransformError> {
        // Execute: transform(event) -> transformed payload
        // Similar pattern to ScriptAttributeResolver.resolve()
    }
}
```

**Example transformation function:**
```javascript
function transform(event) {
  return {
    event_type: event.headers['x-event-type'] || event.body.type,
    payload: {
      id: event.body.data.object.id,
      amount_cents: Math.round(event.body.data.object.amount * 100),
      metadata: event.body.data.object.metadata || {}
    }
  };
}
```

### 8.4 Filter Functions

Filter functions also use the same QuickJS infrastructure:

```javascript
function filter(event) {
  // Return true to match this route, false to skip
  return event.body.type === 'payment_intent.succeeded'
      && event.body.data.object.amount >= 1000;
}
```

---

## 9. Promise Resolution Design

### 9.1 Practical Example: Stripe Payment Webhook Flow

This example shows how the e-commerce order workflow would change from a synchronous task-based payment to a webhook-oriented flow using Stripe.

#### Current Flow (Synchronous Task)

```rust
// Current: Payment processed synchronously via task
let payment_result = ctx
    .schedule_raw("payment-task", payment_input_value)
    .await?;  // Blocks until task completes
let payment_response: PaymentResponse = serde_json::from_value(payment_result)?;
```

The task worker calls Stripe, waits for the result, and returns it. This works for simple charges but **doesn't handle**:
- 3D Secure authentication (requires customer interaction)
- Asynchronous payment methods (bank transfers, SEPA)
- Payment processing delays

#### Webhook-Oriented Flow with Promises

```rust
// Step 1: Create a promise for the payment callback
let promise_id = format!("payment-{}", input.order_id);
ctx.create_promise(&promise_id, Some(Duration::from_secs(3600))).await?;

// Step 2: Create PaymentIntent via task, passing promise_id in metadata
let payment_input = CreatePaymentIntentInput {
    order_id: input.order_id.clone(),
    amount: input.total_amount,
    currency: "usd".to_string(),
    customer_id: input.customer_id.clone(),
    // CRITICAL: Pass promise_id so Stripe webhook can resolve it
    metadata: json!({
        "flovyn_promise_id": promise_id,
        "order_id": input.order_id,
    }),
};

let create_result = ctx
    .schedule_raw("create-payment-intent", serde_json::to_value(&payment_input)?)
    .await?;
let payment_intent: PaymentIntentCreated = serde_json::from_value(create_result)?;

// Store payment intent ID for potential cancellation/refund
ctx.set_raw("paymentIntentId", serde_json::to_value(&payment_intent.id)?).await?;
ctx.set_raw("status", serde_json::to_value(OrderStatus::AwaitingPayment)?).await?;

info!(
    order_id = %input.order_id,
    payment_intent_id = %payment_intent.id,
    "PaymentIntent created, waiting for webhook"
);

// Step 3: Wait for webhook to resolve the promise
// Workflow suspends here until:
// - Stripe sends payment_intent.succeeded webhook → promise resolved
// - Stripe sends payment_intent.payment_failed webhook → promise rejected
// - Timeout expires → promise times out
let payment_result = ctx.await_promise::<PaymentWebhookResult>(&promise_id).await?;

// Step 4: Handle the result
match payment_result.status.as_str() {
    "succeeded" => {
        info!(order_id = %input.order_id, "Payment succeeded via webhook");
        ctx.set_raw("status", serde_json::to_value(OrderStatus::PaymentCompleted)?).await?;
        // Continue to inventory reservation...
    }
    "failed" => {
        error!(order_id = %input.order_id, reason = ?payment_result.failure_reason, "Payment failed");
        ctx.set_raw("status", serde_json::to_value(OrderStatus::Failed)?).await?;
        return Ok(OrderOutput::failed(&input.order_id, &payment_result.failure_reason));
    }
    _ => {
        return Err(anyhow!("Unexpected payment status: {}", payment_result.status));
    }
}
```

#### Eventhook Configuration

**Source: `stripe-payments`**
```json
{
  "name": "Stripe Payments",
  "slug": "stripe-payments",
  "verifier_type": "hmac",
  "verifier_config": {
    "header": "Stripe-Signature",
    "secret": "${STRIPE_WEBHOOK_SECRET}",
    "algorithm": "sha256"
  }
}
```

**Route: Resolve promise on `payment_intent.succeeded`**
```json
{
  "name": "Payment Success",
  "priority": 10,
  "action_type": "resolve_promise",
  "filter_event_types": ["payment_intent.succeeded"],
  "action_config": {
    "promise_id_path": "body.data.object.metadata.flovyn_promise_id",
    "value_mapping": {
      "type": "jmespath",
      "expression": "{status: 'succeeded', payment_intent_id: body.data.object.id, amount: body.data.object.amount}"
    }
  }
}
```

**Route: Reject promise on `payment_intent.payment_failed`**
```json
{
  "name": "Payment Failed",
  "priority": 10,
  "action_type": "reject_promise",
  "filter_event_types": ["payment_intent.payment_failed"],
  "action_config": {
    "promise_id_path": "body.data.object.metadata.flovyn_promise_id",
    "error_path": "body.data.object.last_payment_error.message"
  }
}
```

#### Stripe Webhook Payload Example

```json
{
  "id": "evt_1234567890",
  "type": "payment_intent.succeeded",
  "data": {
    "object": {
      "id": "pi_abc123",
      "amount": 5998,
      "currency": "usd",
      "status": "succeeded",
      "metadata": {
        "flovyn_promise_id": "payment-ORD-TEST-001",
        "order_id": "ORD-TEST-001"
      }
    }
  }
}
```

#### Idempotency Considerations

**Problem:** Stripe may send the same webhook multiple times (retries on timeout, network issues).

**Solution:** Promise resolution is already idempotent by design:

```rust
// In promise_repository.rs - resolve() only updates if not already resolved
pub async fn resolve(&self, id: &str, value: Vec<u8>, ...) -> Result<(), sqlx::Error> {
    sqlx::query(
        "UPDATE promise SET resolved = TRUE, value = $1, ... WHERE id = $4 AND resolved = FALSE"
    )
    // ...
}
```

However, for the eventhook plugin, we should also track processed webhook events:

1. **Event-level idempotency:** Store `idempotency_key` from webhook payload
   - Stripe: Use `event.id` (e.g., `evt_1234567890`)
   - Configure source: `"idempotency_keys": ["body.id"]`

2. **Action-level idempotency:** The promise resolution itself is idempotent
   - First call: resolves the promise, workflow continues
   - Subsequent calls: promise already resolved, no-op

**Webhook Source Configuration with Idempotency:**
```json
{
  "name": "Stripe Payments",
  "slug": "stripe-payments",
  "idempotency_keys": ["body.id"],
  "verifier_type": "hmac",
  "verifier_config": { ... }
}
```

When a duplicate event arrives:
1. Gateway extracts `body.id` → `evt_1234567890`
2. Checks if event with this idempotency key already processed
3. If duplicate: marks event as `is_duplicate=true`, returns 200 OK, skips processing
4. If new: processes normally

#### Sequence Diagram

```
┌─────────┐     ┌──────────┐     ┌────────┐     ┌───────┐     ┌─────────────────┐
│Workflow │     │Task Worker│     │ Stripe │     │Webhook│     │Eventhook  │
└────┬────┘     └────┬─────┘     └───┬────┘     └───┬───┘     └────────┬────────┘
     │               │               │              │                   │
     │ create_promise("payment-ORD-001")            │                   │
     │──────────────────────────────────────────────│───────────────────│
     │               │               │              │                   │
     │ schedule_raw("create-payment-intent")        │                   │
     │──────────────►│               │              │                   │
     │               │ POST /v1/payment_intents     │                   │
     │               │ (metadata: flovyn_promise_id)│                   │
     │               │──────────────►│              │                   │
     │               │◄──────────────│              │                   │
     │               │ {id: pi_abc123, status: requires_action}         │
     │◄──────────────│               │              │                   │
     │               │               │              │                   │
     │ await_promise("payment-ORD-001")             │                   │
     │ ─ ─ ─ ─ ─ ─ ─(workflow suspended)─ ─ ─ ─ ─ ─│                   │
     │               │               │              │                   │
     │               │               │ Customer completes 3DS           │
     │               │               │              │                   │
     │               │               │ POST /eventhook/acme/stripe       │
     │               │               │──────────────►──────────────────►│
     │               │               │              │                   │
     │               │               │              │  Verify signature │
     │               │               │              │  Extract promise_id
     │               │               │              │  POST /api/.../promises/.../resolve
     │               │               │              │                   │
     │◄─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─(promise resolved)─ ─ ─ ─ ─ ─ ─ ─ ─│
     │               │               │              │                   │
     │ Continue workflow...          │              │                   │
     │               │               │              │                   │
```

### 9.2 Current Promise Model

Flovyn promises are resolved **by ID only**. The promise model:

```rust
pub struct Promise {
    pub id: String,                    // Primary lookup key
    pub name: String,                  // Stored but NOT used for lookup
    pub workflow_execution_id: Uuid,
    pub resolved: bool,
    pub value: Option<Vec<u8>>,
    pub error: Option<String>,
    // ...
}
```

The gRPC API only supports ID-based resolution:
```protobuf
message ResolvePromiseRequest {
  string promise_id = 1;
  bytes value = 2;
}
```

### 9.2 Promise Lookup Strategy

Since resolution is by ID, the webhook route configuration extracts the promise ID from the webhook payload:

```json
{
  "action_type": "resolve_promise",
  "action_config": {
    "promise_id_path": "body.metadata.promise_id",
    "value_mapping": {
      "type": "jmespath",
      "expression": "body.result"
    }
  }
}
```

**Workflow Integration Pattern:**
1. Workflow creates a promise with a unique ID (e.g., `prom_abc123`)
2. Workflow sends this ID to the external system (in API call metadata, webhook callback URL, etc.)
3. External system includes the promise ID when calling the webhook
4. Webhook gateway extracts the ID and resolves the promise

Example webhook payload from external system:
```json
{
  "event": "payment.completed",
  "metadata": {
    "promise_id": "prom_abc123"
  },
  "result": {
    "transaction_id": "txn_xyz",
    "amount": 1000
  }
}
```

### 9.3 Resolve vs Reject

The webhook route should specify whether to resolve or reject:

```json
{
  "action_type": "resolve_promise",
  "action_config": {
    "promise_lookup": { "type": "id", "path": "body.promise_id" },
    "value_mapping": { "type": "jmespath", "expression": "body.result" }
  }
}
```

```json
{
  "action_type": "reject_promise",
  "action_config": {
    "promise_lookup": { "type": "id", "path": "body.promise_id" },
    "error_path": "body.error.message"
  }
}
```

Or use a filter to determine which action to take:
- Route 1: `filter: body.status == 'success'` → `resolve_promise`
- Route 2: `filter: body.status == 'failed'` → `reject_promise`

### 9.4 New REST Endpoints for Promises (Core Server)

Currently, promise resolution is gRPC-only. **The main server** (not the plugin) should add REST endpoints:

```
POST /api/orgs/{slug}/promises/{promise_id}/resolve
Body: { "value": { ... } }

POST /api/orgs/{slug}/promises/{promise_id}/reject
Body: { "error": "Error message" }
```

This is a prerequisite for the eventhook plugin plugin. The plugin will call these core APIs when executing `resolve_promise` or `reject_promise` actions.

**Why in core server (not plugin):**
- Promise resolution is a fundamental Flovyn capability
- Other integrations beyond webhooks may need REST-based promise resolution
- Keeps the plugin focused on webhook-specific concerns (ingestion, routing, verification)

---

## 10. UI Requirements

### 10.1 Webhook Sources View

- List all sources with status indicators (enabled/disabled, last event time)
- Show webhook URL for each source (copyable)
- Quick actions: enable/disable, copy URL, delete
- Source detail page with configuration editor

### 10.2 Routes Configuration

- Visual route builder (drag-and-drop priority ordering)
- Filter condition builder:
  - Event type selector (with autocomplete from seen events)
  - Header condition builder
  - Body condition builder (with JSON path helper)
- Action configuration forms (workflow kind dropdown, task kind dropdown)
- Test mode: paste sample payload, see which routes match

### 10.3 Events Log

- Real-time event stream (SSE-based)
- Filter by: source, status, date range, event type
- Event detail view:
  - Request tab: headers, raw payload, parsed payload
  - Verification tab: verified status, algorithm used
  - Actions tab: list of triggered actions with status
  - Links tab: links to created workflows/tasks
- Replay button for failed events
- Bulk operations: retry all failed, delete old events

### 10.4 Debugging Tools

- **Payload Inspector**: Syntax-highlighted JSON with path display on hover
- **JMESPath Tester**: Input field + expression field + result preview
- **Filter Tester**: Sample payload + filter config + match result
- **Transformation Preview**: Before/after view with live updates

### 10.5 Webhook URL Builder

- Generate webhook URL with source slug
- Show example `curl` command for testing
- Provider-specific setup instructions (GitHub webhook configuration, Stripe webhook setup, etc.)

---

## 11. Security Considerations

### 11.1 URL Security

Options:
- **Slug only**: `/eventhook/{org}/{source}` - relies on verification for security
- **Slug + token**: `/eventhook/{org}/{source}?token=xyz` - extra layer
- **Token in path**: `/eventhook/{org}/{source}/{token}` - rotatable

Recommendation: Slug for readability + verifier for security. Optional token for sources without built-in verification.

### 11.2 Rate Limiting

- Per-source rate limits (configurable)
- Per-org rate limits (default, overridable)
- Burst allowance configuration
- 429 response with `Retry-After` header
- Track by source IP for anonymous sources

### 11.3 Payload Size Limits

- Configurable per-source max payload size
- Default: 1MB
- Maximum: 10MB (org-configurable)
- 413 Payload Too Large response

### 11.4 IP Allowlisting (Optional)

- Per-source IP allowlist
- Support for CIDR ranges
- Warning mode before enforcement (log but allow)
- Known provider IP ranges (GitHub, Stripe, etc.)

### 11.5 Secret Management

- Verification secrets encrypted at rest (using org key or system key)
- Secrets never exposed in API responses
- Audit logging for secret access
- Token rotation with grace period (old tokens valid for N hours)

### 11.6 Input Sanitization

- Strip sensitive headers before storage (Authorization, Cookie, etc.)
- Size limits on headers and individual header values
- Content-Type validation before parsing

---

## 12. Implementation Phases

### Phase 1: Core Infrastructure (MVP)

1. Database schema and migrations for all tables
2. WebhookSource CRUD API
3. Basic ingest endpoint (no routing, just storage)
4. Event storage and retrieval API
5. HMAC verification (most common provider pattern)
6. Single-route trigger_workflow action

**Deliverables:**
- Receive webhooks from GitHub/Stripe
- Store all events for debugging
- Trigger a workflow on every event

### Phase 2: Routing and Multiple Actions

**Prerequisite (Core Server):**
- Add REST endpoints for promise resolution: `POST /api/orgs/{slug}/promises/{id}/resolve|reject`

**Plugin Work:**
1. WebhookRoute CRUD API
2. Route evaluation engine with priority ordering
3. Filter evaluation (event type, headers, body)
4. Action executors:
   - Trigger workflow (with input mapping)
   - Create task
   - Resolve/reject promise (calls core server API)
5. Event processing queue (using NATS or internal)

**Deliverables:**
- Multiple routes per source
- Filter by event type or payload content
- All three action types working

### Phase 3: Advanced Features

1. Additional verifiers (BasicAuth, APIKey, provider templates)
2. JavaScript transformations (reuse `flovyn-auth-script` / `rquickjs`)
3. Filter functions (JavaScript)
4. Idempotency handling (configurable extraction)
5. Event replay functionality
6. Custom responses

**Deliverables:**
- Support for any webhook provider
- Flexible payload transformation
- Deduplication for providers that retry

### Phase 4: Observability and Production Hardening

1. Metrics (events received, verified, processed, failed)
2. Event streaming SSE endpoint for real-time UI
3. Webhook source health monitoring
4. Alerting on repeated failures
5. Rate limiting implementation
6. IP allowlisting

**Deliverables:**
- Production-ready with monitoring
- Protection against abuse

---

## 13. Testing Strategy

### 13.1 Unit Tests

- `WebhookSourceAuthenticator` verification methods (HMAC, BasicAuth, ApiKey)
- Input mapping/transformation (JMESPath, passthrough)
- Filter evaluation logic
- Idempotency key extraction

### 13.2 Integration Tests

Using testcontainers (existing pattern):

1. **End-to-end webhook flow:**
   - Create source and route
   - POST to ingest endpoint
   - Verify event stored
   - Verify workflow/task created

2. **Verification tests:**
   - Valid signature → 200 + verified=true
   - Invalid signature → 401 (or 200) + verified=false
   - Missing signature → appropriate error

3. **Routing tests:**
   - Multiple routes, verify correct ones match
   - Priority ordering respected
   - Disabled routes skipped

4. **Action tests:**
   - trigger_workflow creates workflow with correct input
   - create_task creates task with correct input
   - resolve_promise resolves correct promise

### 13.3 Provider-Specific Tests

Mock webhook payloads from common providers:
- GitHub (push, pull_request, issues)
- Stripe (payment_intent.succeeded, invoice.paid)
- Shopify (orders/create, orders/paid)

---

## 14. Open Questions

1. ~~**JavaScript Engine**: Which to use for transformations?~~
   - **RESOLVED**: Use existing `flovyn-auth-script` crate (QuickJS via `rquickjs`)
   - See `flovyn-server/crates/auth-script/README.md` for documentation

2. **Event Retention**: How long to keep webhook events?
   - Configurable per-org?
   - Default 30 days?
   - Separate raw payload retention (can be shorter)?
   - **Recommendation**: Org-configurable, default 30 days

3. **Sync vs Async Processing**:
   - Current design: Return 200 immediately, process async
   - Alternative: Wait for route evaluation before returning
   - **Recommendation**: Async for reliability (webhook senders have timeouts)

4. **Multiple Route Matches**:
   - Stop after first match?
   - Execute all matching routes?
   - **Recommendation**: Execute all matching routes (more flexible)

5. **Failed Action Retry**:
   - Retry at event level or action level?
   - How many retries?
   - **Recommendation**: Action level, configurable per route

6. **Correlation for Promise Resolution**:
   - Require promise ID in webhook?
   - Support correlation lookup?
   - **Recommendation**: Start with ID-based, add correlation later

---

# Part 2: Outbound Webhook Delivery

**Date:** 2024-12-30
**Status:** Research
**Scope:** Outbound webhook delivery to external systems

---

## 16. Outbound Webhooks Overview

While Part 1 focused on **inbound** webhooks (receiving from external providers), this section explores **outbound** webhooks—delivering events from Flovyn to external systems.

### 16.1 Use Cases

1. **Workflow Event Notifications**: Notify external systems when workflows complete, fail, or reach milestones
2. **Task Completion Callbacks**: Send results to downstream systems after task execution
3. **Integration with External Services**: Push data to third-party APIs (Slack, Email, CRMs, etc.)
4. **Event Broadcasting**: Fan-out events to multiple subscribers

### 16.2 Reference: Convoy's Outbound Architecture

Convoy provides a comprehensive outbound webhook system. Key components:

**Endpoint** (destination):
```go
type Endpoint struct {
    UID                string
    ProjectID          string
    Url                string                  // Target URL
    Name               string
    Secrets            Secrets                 // For signature generation
    AdvancedSignatures bool
    Status             EndpointStatus          // active, inactive, pending
    HttpTimeout        uint64
    Authentication     *EndpointAuthentication // Basic, API Key, OAuth2
    RateLimit          int
    RateLimitDuration  uint64
    MtlsClientCert     *MtlsClientCert        // mTLS support
    OAuth2Config       *OAuth2                // OAuth2 token refresh
}
```

**EventDelivery** (delivery attempt tracking):
```go
type EventDelivery struct {
    UID            string
    EventID        string
    EndpointID     string
    SubscriptionID string
    Headers        HTTPHeader
    Status         EventDeliveryStatus  // scheduled, processing, success, failed, retry
    DeliveryMode   DeliveryMode         // at_least_once, exactly_once
    Metadata       *Metadata            // includes retry count, next retry time
    LatencySeconds float64
}
```

**DeliveryAttempt** (individual attempt record):
```go
type DeliveryAttempt struct {
    UID             string
    URL             string
    Method          string
    RequestHeader   HttpHeader
    ResponseHeader  HttpHeader
    HttpResponseCode string
    ResponseData    []byte
    Error           string
    Status          bool
    CreatedAt       time.Time
}
```

**Key Patterns:**
- **Subscription-based routing**: Events → Subscriptions → Endpoints
- **Delivery tracking**: Each attempt is logged with full HTTP details
- **Retry strategies**: Linear/exponential backoff with configurable limits
- **Circuit breaker**: Pause deliveries to failing endpoints
- **Rate limiting**: Per-endpoint request rate control
- **Signature generation**: HMAC signatures for payload verification

---

## 17. Flovyn Outbound Webhook Design

### 17.1 Integration with Workflows

Outbound webhooks in Flovyn would integrate as **workflow actions**:

```rust
// In a workflow, send a webhook as a task
let webhook_result = ctx
    .schedule_raw("http-request", json!({
        "url": "https://api.example.com/callback",
        "method": "POST",
        "headers": {
            "Content-Type": "application/json",
            "X-Custom-Header": "value"
        },
        "body": {
            "order_id": order_id,
            "status": "completed"
        },
        "timeout_ms": 30000,
        "retry_policy": {
            "max_attempts": 3,
            "backoff": "exponential",
            "initial_delay_ms": 1000
        }
    }))
    .await?;
```

### 17.2 Proposed Data Model

#### OutboundEndpoint
```sql
CREATE TABLE p_eventhook__outbound_endpoint (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES organization(id),

    -- Identification
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(255) NOT NULL,

    -- Target configuration
    url TEXT NOT NULL,
    http_method VARCHAR(10) NOT NULL DEFAULT 'POST',

    -- Authentication
    auth_type VARCHAR(50),  -- 'none', 'basic', 'bearer', 'api_key', 'oauth2'
    auth_config JSONB,      -- Type-specific config (encrypted)

    -- Signature generation (for receiver verification)
    signing_secret TEXT,
    signing_algorithm VARCHAR(50) DEFAULT 'hmac-sha256',

    -- Headers
    default_headers JSONB,

    -- Rate limiting
    rate_limit INT,
    rate_limit_window_seconds INT,

    -- Timeout
    timeout_ms INT DEFAULT 30000,

    -- Status
    status VARCHAR(50) NOT NULL DEFAULT 'active',

    -- mTLS (optional)
    mtls_cert TEXT,
    mtls_key TEXT,
    mtls_ca TEXT,

    -- Metadata
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted_at TIMESTAMPTZ,

    UNIQUE(org_id, slug) WHERE deleted_at IS NULL
);
```

#### OutboundDelivery
```sql
CREATE TABLE p_eventhook__outbound_delivery (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES organization(id),
    endpoint_id UUID NOT NULL REFERENCES p_eventhook__outbound_endpoint(id),

    -- Source reference (what triggered this delivery)
    source_type VARCHAR(50) NOT NULL,  -- 'workflow', 'task', 'event'
    source_id UUID,
    workflow_execution_id UUID REFERENCES workflow_execution(id),
    task_execution_id UUID REFERENCES task_execution(id),

    -- Request
    request_url TEXT NOT NULL,
    request_method VARCHAR(10) NOT NULL,
    request_headers JSONB NOT NULL,
    request_body BYTEA,

    -- Status
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    -- 'pending', 'processing', 'success', 'failed', 'retrying'

    -- Retry tracking
    attempt_count INT NOT NULL DEFAULT 0,
    max_attempts INT NOT NULL DEFAULT 3,
    next_retry_at TIMESTAMPTZ,

    -- Timing
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    completed_at TIMESTAMPTZ,

    -- Idempotency
    idempotency_key VARCHAR(512)
);

CREATE INDEX idx_outbound_delivery_pending
    ON p_eventhook__outbound_delivery(org_id, status, next_retry_at)
    WHERE status IN ('pending', 'retrying');
```

#### OutboundDeliveryAttempt
```sql
CREATE TABLE p_eventhook__outbound_delivery_attempt (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    delivery_id UUID NOT NULL REFERENCES p_eventhook__outbound_delivery(id),

    -- Request sent
    attempt_number INT NOT NULL,

    -- Response received
    response_status_code INT,
    response_headers JSONB,
    response_body BYTEA,

    -- Error (if any)
    error_type VARCHAR(100),
    error_message TEXT,

    -- Timing
    started_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    completed_at TIMESTAMPTZ,
    latency_ms INT
);
```

### 17.3 Delivery Flow

```
1. Workflow/Task triggers outbound webhook
   │
2. Create OutboundDelivery record (status='pending')
   │
3. Scheduler picks up pending deliveries
   │
4. For each delivery:
   │ ├── Build HTTP request (URL, headers, body)
   │ ├── Apply authentication (inject token, sign payload)
   │ ├── Create DeliveryAttempt record
   │ │
   │ ├── Send HTTP request
   │ │
   │ ├── On success (2xx):
   │ │   ├── Record response in attempt
   │ │   ├── Update delivery status='success'
   │ │   └── Return result to workflow (if awaited)
   │ │
   │ └── On failure:
   │     ├── Record error in attempt
   │     ├── If retries remaining:
   │     │   ├── Calculate next_retry_at (backoff)
   │     │   └── Update status='retrying'
   │     └── If max retries exceeded:
   │         ├── Update status='failed'
   │         └── Optionally trigger failure callback
```

### 17.4 Retry Strategies

| Strategy | Description | Use Case |
|----------|-------------|----------|
| `linear` | Fixed delay between retries | Simple, predictable |
| `exponential` | Delay doubles each retry (1s, 2s, 4s, 8s...) | Network issues |
| `exponential_jitter` | Exponential + random jitter | Avoid thundering herd |

Configuration:
```json
{
  "strategy": "exponential_jitter",
  "initial_delay_ms": 1000,
  "max_delay_ms": 300000,
  "max_attempts": 5
}
```

### 17.5 Signature Generation

Following [Standard Webhooks](https://www.standardwebhooks.com/):

```rust
fn sign_payload(
    secret: &[u8],
    timestamp: i64,
    payload: &[u8],
) -> String {
    let message = format!("{}.{}", timestamp, String::from_utf8_lossy(payload));
    let signature = hmac_sha256(secret, message.as_bytes());
    base64::encode(signature)
}

// Headers sent with webhook:
// webhook-id: msg_xxxxx
// webhook-timestamp: 1234567890
// webhook-signature: v1,base64signature
```

---

# Part 3: n8n-like Workflow Automation Capabilities

**Date:** 2024-12-30
**Status:** Research
**Scope:** Comparison with n8n, integration patterns

---

## 18. n8n Architecture Analysis

### 18.1 Core Concepts

[n8n](https://n8n.io/) is a workflow automation platform with:

1. **Visual Node Editor**: Drag-and-drop workflow builder
2. **Trigger Nodes**: Start workflows from webhooks, schedules, or events
3. **Action Nodes**: HTTP requests, database operations, service integrations
4. **Data Transformation**: JavaScript code, expressions, built-in functions
5. **Branching/Looping**: Conditional paths, loops over data

### 18.2 n8n HTTP Request Node

The HTTP Request node (`HttpRequestV3.node.ts`) provides:

**Authentication Options:**
- Basic Auth
- Bearer Token
- Digest Auth
- Header Auth (custom header)
- Query Auth (API key in URL)
- OAuth1/OAuth2
- SSL/mTLS certificates

**Request Configuration:**
- Method: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS
- URL with expression support
- Query parameters (key-value or JSON)
- Headers (key-value or JSON)
- Body types: JSON, Form URL-encoded, Multipart, Binary, Raw

**Response Handling:**
- Auto-detect response format (JSON, text, binary)
- Full response mode (headers, status, body)
- Pagination support (cursor, page, offset)

**Error Handling:**
- "Continue on fail" option
- Configurable status codes
- Retry with batching intervals

### 18.3 n8n Webhook Response

n8n supports returning data from workflow execution:

```typescript
// Response options:
// - Immediately: Return 200 with "Workflow started"
// - When Last Node Finishes: Return output of final node
// - Using 'Respond to Webhook' Node: Custom response
// - Streaming: Real-time data streaming
```

---

## 19. Mapping n8n Capabilities to Flovyn

### 19.1 Capability Comparison

| n8n Feature | Flovyn Equivalent | Status |
|-------------|-------------------|--------|
| **Webhook Trigger** | Inbound eventhook plugin (Part 1) | Proposed |
| **HTTP Request** | Task-based HTTP requests | New |
| **400+ Integrations** | Task workers per integration | Extensible |
| **Visual Editor** | UI component (separate project) | Future |
| **JavaScript Code** | JS transformation in webhook routes | Proposed |
| **Scheduling** | Timer-based workflow triggers | Existing |
| **Branching** | Workflow logic in worker code | Existing |
| **Data Passing** | Workflow state, task inputs/outputs | Existing |
| **Error Handling** | Task retries, workflow error states | Existing |

### 19.2 Flovyn Advantages for Workflow Automation

1. **Event Sourcing**: Full audit trail of all workflow decisions
2. **Durability**: Workflows survive server restarts
3. **Long-running**: Workflows can wait days/weeks (timers, promises)
4. **Programmatic Control**: Full programming language, not limited to visual editor

### 19.3 Integration Pattern: HTTP Request Task

Rather than building HTTP Request as a core feature, implement it as a **task type** that workflows can use:

```rust
// Worker implements HTTP request task type
#[task("http-request")]
async fn http_request_task(ctx: TaskContext) -> Result<HttpResponse> {
    let config: HttpRequestConfig = ctx.parse_input()?;

    let client = reqwest::Client::builder()
        .timeout(Duration::from_millis(config.timeout_ms))
        .build()?;

    let mut request = client.request(config.method, &config.url);

    // Apply headers
    for (key, value) in config.headers {
        request = request.header(key, value);
    }

    // Apply authentication
    match config.auth {
        AuthConfig::Bearer(token) => {
            request = request.bearer_auth(token);
        }
        AuthConfig::Basic { username, password } => {
            request = request.basic_auth(username, password);
        }
        // ... other auth types
    }

    // Send request
    let response = request
        .body(config.body)
        .send()
        .await?;

    Ok(HttpResponse {
        status: response.status().as_u16(),
        headers: response.headers().clone(),
        body: response.bytes().await?,
    })
}
```

### 19.4 Workflow Example: n8n-style Automation

```rust
// Flovyn workflow equivalent to n8n HTTP automation
#[workflow]
async fn process_order_webhook(ctx: WorkflowContext) -> Result<OrderResult> {
    let input: OrderWebhook = ctx.parse_input()?;

    // Step 1: Validate with external API
    let validation = ctx.schedule_raw("http-request", json!({
        "url": "https://validator.example.com/orders",
        "method": "POST",
        "body": { "order_id": input.order_id }
    })).await?;

    // Step 2: Branch based on validation
    if !validation["valid"].as_bool().unwrap_or(false) {
        // Send notification on failure
        ctx.schedule_raw("http-request", json!({
            "url": "https://hooks.slack.com/services/xxx",
            "method": "POST",
            "body": {
                "text": format!("Order {} validation failed", input.order_id)
            }
        })).await?;
        return Ok(OrderResult::ValidationFailed);
    }

    // Step 3: Process payment (wait for webhook callback)
    let promise_id = format!("payment-{}", input.order_id);
    ctx.create_promise(&promise_id, Duration::from_secs(3600)).await?;

    ctx.schedule_raw("http-request", json!({
        "url": "https://api.stripe.com/v1/payment_intents",
        "method": "POST",
        "auth": { "type": "bearer", "token": "${STRIPE_KEY}" },
        "body": {
            "amount": input.amount,
            "metadata": { "promise_id": promise_id }
        }
    })).await?;

    let payment_result = ctx.await_promise(&promise_id).await?;

    // Step 4: Send confirmation
    ctx.schedule_raw("http-request", json!({
        "url": "https://api.sendgrid.com/v3/mail/send",
        "method": "POST",
        "auth": { "type": "bearer", "token": "${SENDGRID_KEY}" },
        "body": {
            "to": input.customer_email,
            "subject": "Order Confirmed",
            "content": format!("Your order {} is confirmed!", input.order_id)
        }
    })).await?;

    Ok(OrderResult::Completed)
}
```

---

## 20. Unified Architecture Evolution

### 20.1 Plugin Architecture

The eventhook plugin evolves into a comprehensive **integration plugin**:

```
plugins/
└── eventhook/
    ├── Cargo.toml
    └── src/
        ├── lib.rs
        ├── inbound/           # Part 1: Receiving webhooks
        │   ├── source.rs
        │   ├── route.rs
        │   ├── event.rs
        │   └── verifier.rs
        ├── outbound/          # Part 2: Sending webhooks
        │   ├── endpoint.rs
        │   ├── delivery.rs
        │   └── signer.rs
        ├── tasks/             # Part 3: Built-in task types
        │   ├── http_request.rs
        │   ├── transform.rs
        │   └── mod.rs
        └── api/
            ├── mod.rs
            ├── inbound_api.rs
            ├── outbound_api.rs
            └── openapi.rs
```

### 20.2 Feature Flags

```toml
[features]
default = ["inbound"]
inbound = []           # Part 1: Receive webhooks
outbound = []          # Part 2: Send webhooks
http-task = []         # Part 3: HTTP request task type
full = ["inbound", "outbound", "http-task"]
```

### 20.3 API Surface

**Inbound (Part 1):**
- `POST /api/orgs/{org_slug}/eventhook/in/{source_slug}` - Receive webhooks
- `GET/POST /api/orgs/{org_slug}/eventhook/sources` - Manage sources
- `GET/POST /api/orgs/{org_slug}/eventhook/events` - View events

**Outbound (Part 2):**
- `GET/POST /api/orgs/{org_slug}/eventhook/endpoints` - Manage endpoints
- `GET /api/orgs/{org_slug}/eventhook/deliveries` - View deliveries
- `POST /api/orgs/{org_slug}/eventhook/deliveries/{id}/retry` - Retry delivery

**Task Types (new):**
- `http-request` - Make HTTP requests from workflows

---

## 21. Future Considerations

### 21.1 Visual Workflow Editor

A visual editor (like n8n) could be built as a **separate frontend project**:

1. **Backend**: Flovyn workflow definitions as JSON/YAML
2. **Frontend**: React-based visual editor
3. **Code Generation**: Convert visual workflow → Rust/JavaScript worker code

### 21.2 Pre-built Integrations

Create task worker templates for common services:
- **Communication**: Slack, Discord, Email (SendGrid, SES), SMS (Twilio)
- **Databases**: PostgreSQL, MongoDB, Redis
- **Cloud**: AWS, GCP, Azure
- **CRM**: Salesforce, HubSpot
- **E-commerce**: Shopify, Stripe

### 21.3 Marketplace

Consider a plugin/integration marketplace where users can:
- Share custom task workers
- Download pre-built integrations
- Contribute to community extensions

---

## 22. Implementation Phases (Updated)

### Phase 1: Inbound Webhooks (MVP)
*As defined in Part 1, sections 1-12*

### Phase 2: Outbound Webhooks
1. OutboundEndpoint CRUD API
2. OutboundDelivery scheduler
3. Delivery attempt tracking
4. Retry logic with backoff
5. Signature generation

### Phase 3: HTTP Request Task
1. Implement `http-request` task type
2. Authentication support (Basic, Bearer, OAuth2)
3. Response parsing and error handling
4. Integration with outbound endpoints (reuse configs)

### Phase 4: Advanced Features
1. Circuit breaker for failing endpoints
2. Rate limiting per endpoint
3. mTLS support
4. OAuth2 token refresh
5. Webhook replay/resend

### Phase 5: Observability
1. Delivery metrics (success rate, latency)
2. Endpoint health monitoring
3. Alerting on failures
4. Real-time delivery status UI

---

## 23. Updated Open Questions

1. **Outbound Endpoint Management**:
   - Global endpoints per org vs. per-workflow endpoints?
   - **Recommendation**: Both—global for reusable configs, inline for one-off

2. **Delivery Guarantees**:
   - At-least-once vs. exactly-once delivery?
   - **Recommendation**: At-least-once by default, exactly-once as option

3. **HTTP Request Task vs. Outbound Delivery**:
   - Use OutboundDelivery tracking for all HTTP tasks?
   - **Recommendation**: Yes, provides unified audit trail

4. **Secret Management**:
   - How to handle API keys, tokens in task configs?
   - **Recommendation**: Reference secrets by name, resolve at runtime

5. **Request/Response Size Limits**:
   - Max payload sizes for outbound webhooks?
   - **Recommendation**: 10MB default, configurable per endpoint

---

## 24. Future: Event Bus Architecture (EventBridge-like)

This section explores evolving Flovyn into a general-purpose **event bus** similar to AWS EventBridge, where events from multiple sources can be routed to workflows, tasks, or external systems based on configurable rules.

### 24.1 Concept Overview

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           FLOVYN EVENT BUS                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │   Webhook   │  │  Workflow   │  │    Task     │  │   Custom    │     │
│  │   Source    │  │   Events    │  │   Events    │  │   Events    │     │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘     │
│         │                │                │                │            │
│         ▼                ▼                ▼                ▼            │
│  ┌──────────────────────────────────────────────────────────────┐       │
│  │                      EVENT ROUTER                             │       │
│  │  ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐              │       │
│  │  │ Rule 1 │  │ Rule 2 │  │ Rule 3 │  │ Rule N │              │       │
│  │  └───┬────┘  └───┬────┘  └───┬────┘  └───┬────┘              │       │
│  └──────┼───────────┼───────────┼───────────┼───────────────────┘       │
│         │           │           │           │                           │
│         ▼           ▼           ▼           ▼                           │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐                    │
│  │ Workflow │ │   Task   │ │  Promise │ │ Outbound │                    │
│  │ Trigger  │ │ Creation │ │ Resolve  │ │ Webhook  │                    │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘                    │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 24.2 Developer Experience

**Core idea:** Developers push events to a single Flovyn endpoint, and routing rules determine which workflows/tasks execute.

```bash
# Developer publishes an event
curl -X POST https://flovyn.example.com/api/orgs/acme/events \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "type": "order.created",
    "data": {
      "order_id": "ORD-123",
      "customer_id": "CUST-456",
      "total": 150.00,
      "items": [{"sku": "WIDGET-1", "qty": 2}]
    }
  }'
```

**Behind the scenes:**
1. Flovyn receives the event
2. Matches against configured rules
3. Triggers appropriate workflows/tasks

```yaml
# Rule 1: All orders trigger inventory check
- name: "Check inventory"
  pattern:
    type: ["order.created"]
  targets:
    - type: workflow
      config: { workflow_kind: "check-inventory" }

# Rule 2: High-value orders get special handling
- name: "VIP order processing"
  pattern:
    type: ["order.created"]
    data:
      total: [{ "numeric": [">=", 100] }]
  targets:
    - type: workflow
      config: { workflow_kind: "vip-order-handler" }
    - type: task
      config: { task_kind: "notify-sales-team" }

# Rule 3: Route to different workflows by item type
- name: "Digital product fulfillment"
  pattern:
    type: ["order.created"]
    data:
      items: { sku: [{ "prefix": "DIGITAL-" }] }
  targets:
    - type: workflow
      config: { workflow_kind: "digital-fulfillment" }
```

**Result:** One `order.created` event can trigger:
- `check-inventory` workflow (always)
- `vip-order-handler` workflow (if total >= 100)
- `notify-sales-team` task (if total >= 100)
- `digital-fulfillment` workflow (if any item is digital)

### 24.3 Event Sources

| Source Type | Description | Example Events |
|-------------|-------------|----------------|
| **Webhooks** | External HTTP callbacks | `webhook.received`, payload from GitHub/Stripe |
| **Workflow** | Workflow lifecycle events | `workflow.started`, `workflow.completed`, `workflow.failed` |
| **Task** | Task lifecycle events | `task.completed`, `task.failed`, `task.progress` |
| **Timer** | Scheduled/cron events | `timer.fired`, `schedule.triggered` |
| **Custom** | Published by workflows/tasks | Any user-defined event type |
| **System** | Internal Flovyn events | `worker.registered`, `org.created` |

### 24.3 Event Schema

```typescript
interface FlovynEvent {
  // Metadata
  id: string;                    // Unique event ID
  source: string;                // e.g., "webhook:github", "workflow:order-processor"
  type: string;                  // e.g., "workflow.completed", "order.created"
  org_id: string;
  timestamp: string;             // ISO 8601

  // Routing
  subject?: string;              // Optional subject for filtering

  // Payload
  data: any;                     // Event-specific data

  // Tracing
  trace_id?: string;
  correlation_id?: string;       // Links related events
}
```

**Example Events:**

```json
// Workflow completed event
{
  "id": "evt_abc123",
  "source": "workflow:order-processor",
  "type": "workflow.completed",
  "org_id": "org-123",
  "timestamp": "2024-12-30T10:00:00Z",
  "data": {
    "workflow_execution_id": "wf-456",
    "workflow_kind": "process-order",
    "output": { "order_id": "ORD-789", "status": "shipped" }
  },
  "correlation_id": "order-ORD-789"
}

// Custom event published by workflow
{
  "id": "evt_def456",
  "source": "workflow:order-processor",
  "type": "order.shipped",
  "org_id": "org-123",
  "timestamp": "2024-12-30T10:01:00Z",
  "data": {
    "order_id": "ORD-789",
    "tracking_number": "1Z999AA10123456784",
    "carrier": "UPS"
  },
  "correlation_id": "order-ORD-789"
}
```

### 24.4 Event Rules (Pattern Matching)

Rules define which events match and where they're routed. Similar to EventBridge:

```typescript
interface EventRule {
  id: string;
  name: string;
  org_id: string;
  enabled: boolean;

  // Pattern matching (all conditions must match)
  pattern: {
    source?: string[];           // Match any of these sources
    type?: string[];             // Match any of these types (supports wildcards)
    data?: JsonPattern;          // Match on data fields
  };

  // Targets (can have multiple)
  targets: EventTarget[];

  // Optional transformation before sending to target
  input_transformer?: InputTransformer;
}

interface EventTarget {
  type: "workflow" | "task" | "promise" | "webhook" | "event_bus";
  config: TargetConfig;
}
```

**Pattern Examples:**

```yaml
# Match all workflow completions
- name: "Log all workflow completions"
  pattern:
    type: ["workflow.completed"]
  targets:
    - type: task
      config: { task_kind: "audit-log" }

# Match specific order events
- name: "Process shipped orders"
  pattern:
    type: ["order.shipped"]
    data:
      carrier: ["UPS", "FedEx"]
  targets:
    - type: workflow
      config: { workflow_kind: "send-shipping-notification" }
    - type: webhook
      config: { endpoint_slug: "analytics-service" }

# Match webhook events from specific source
- name: "GitHub PR events"
  pattern:
    source: ["webhook:github"]
    type: ["pull_request.*"]
  targets:
    - type: workflow
      config: { workflow_kind: "pr-review-workflow" }

# Match with data filtering
- name: "High-value orders"
  pattern:
    type: ["order.created"]
    data:
      total_amount: [{ "numeric": [">=", 1000] }]
  targets:
    - type: workflow
      config: { workflow_kind: "vip-order-handler" }
```

### 24.5 Publishing Events from Workflows

Workflows can publish custom events to the event bus:

```rust
#[workflow]
async fn process_order(ctx: WorkflowContext) -> Result<OrderResult> {
    let input: OrderInput = ctx.parse_input()?;

    // Process the order...
    let shipping_result = ctx.schedule_raw("ship-order", ...).await?;

    // Publish event to event bus
    ctx.publish_event(FlovynEvent {
        event_type: "order.shipped",
        data: json!({
            "order_id": input.order_id,
            "tracking_number": shipping_result.tracking_number,
            "carrier": shipping_result.carrier,
        }),
        correlation_id: Some(format!("order-{}", input.order_id)),
    }).await?;

    Ok(OrderResult::shipped(shipping_result))
}
```

### 24.6 Built-in Event Types

Flovyn automatically publishes these events:

| Event Type | Source | When |
|------------|--------|------|
| `workflow.started` | `system:workflows` | Workflow execution begins |
| `workflow.completed` | `system:workflows` | Workflow completes successfully |
| `workflow.failed` | `system:workflows` | Workflow fails |
| `workflow.cancelled` | `system:workflows` | Workflow is cancelled |
| `task.started` | `system:tasks` | Task execution begins |
| `task.completed` | `system:tasks` | Task completes successfully |
| `task.failed` | `system:tasks` | Task fails after all retries |
| `timer.fired` | `system:timers` | Timer expires |
| `promise.resolved` | `system:promises` | Promise is resolved |
| `promise.rejected` | `system:promises` | Promise is rejected |
| `webhook.received` | `webhook:{source}` | Webhook received and validated |

**Existing Infrastructure:**

Flovyn already has `StreamEventPublisher` (`server/src/streaming/`) that publishes lifecycle events for SSE streaming:

```rust
// server/src/domain/task_stream.rs - StateEventPayload
pub struct StateEventPayload {
    pub payload_type: &'static str,  // "Event"
    pub event: &'static str,         // "WORKFLOW_STARTED", "TASK_COMPLETED", etc.
    pub data: StateEventData,        // WorkflowSnapshot, TaskSnapshot, etc.
    pub timestamp_ms: i64,
}
```

| Existing (StreamEventPublisher) | New (EventBusPublisher) |
|--------------------------------|-------------------------|
| Per-workflow scoped | Org-scoped |
| Fire-and-forget (no persistence) | Persisted + routed to rules |
| For SSE clients watching workflow | For triggering other workflows/tasks |
| In-memory + NATS backends | Reuse same backends |

**Implementation approach:** Keep existing patterns, extend for event bus.

### 24.6.1 Unified Event Publishing Architecture

The key insight: **keep publish/subscribe patterns simple and backend-agnostic**.

```
┌─────────────────────────────────────────────────────────────────┐
│                        EventPublisher                           │
│  publish_stream(TaskStreamEvent)  // existing SSE streaming     │
│  publish_event(FlovynEvent)       // new event bus              │
└─────────────────────┬───────────────────────────────────────────┘
                      │
          ┌───────────┴───────────┐
          │                       │
          ▼                       ▼
┌─────────────────┐     ┌─────────────────┐
│ InMemoryBackend │     │   NatsBackend   │
│  HashMap<K, V>  │     │  subjects/subs  │
└─────────────────┘     └─────────────────┘
```

**Publisher/Subscriber Traits with Pattern Matching:**

```rust
// server/src/streaming/mod.rs

/// Event pattern for filtering subscriptions.
/// Works identically for both in-memory and NATS backends.
#[derive(Clone, Debug)]
pub struct EventPattern {
    /// Org scope (required for event bus)
    pub org_id: Option<Uuid>,
    /// Event type prefix (e.g., "workflow", "webhook.github")
    /// None = all events, Some("workflow") = workflow.*, Some("workflow.completed") = exact
    pub event_type: Option<String>,
}

impl EventPattern {
    pub fn all_for_org(org_id: Uuid) -> Self {
        Self { org_id: Some(org_id), event_type: None }
    }

    pub fn by_type(org_id: Uuid, event_type: &str) -> Self {
        Self { org_id: Some(org_id), event_type: Some(event_type.to_string()) }
    }

    /// Check if an event matches this pattern
    pub fn matches(&self, event: &FlovynEvent) -> bool {
        // Org must match if specified
        if let Some(tid) = self.org_id {
            if event.org_id != tid {
                return false;
            }
        }
        // Event type prefix matching
        match &self.event_type {
            None => true,  // Match all
            Some(pattern) => event.event_type.starts_with(pattern),
        }
    }
}

/// Unified event publisher for all event types.
#[async_trait]
pub trait EventPublisher: Send + Sync {
    /// Publish stream event (for SSE - existing behavior).
    async fn publish_stream(&self, event: TaskStreamEvent) -> Result<(), StreamError>;

    /// Publish bus event (for event routing - new).
    async fn publish_event(&self, event: FlovynEvent) -> Result<(), StreamError>;
}

/// Subscribe to stream events (for SSE).
pub trait StreamSubscriber: Send + Sync {
    fn subscribe_stream(&self, workflow_id: &str)
        -> Pin<Box<dyn Stream<Item = TaskStreamEvent> + Send>>;
}

/// Subscribe to bus events (for rules engine).
pub trait EventSubscriber: Send + Sync {
    /// Subscribe with pattern matching.
    /// - `EventPattern::all_for_org(id)` → all events for org
    /// - `EventPattern::by_type(id, "workflow")` → workflow.* events
    /// - `EventPattern::by_type(id, "webhook.github")` → webhook.github.* events
    fn subscribe_events(&self, pattern: EventPattern)
        -> Pin<Box<dyn Stream<Item = FlovynEvent> + Send>>;
}
```

**In-Memory Backend with Pattern Matching:**

```rust
pub struct InMemoryEventPublisher {
    // Existing: keyed by workflow_id
    stream_channels: RwLock<HashMap<String, broadcast::Sender<TaskStreamEvent>>>,
    // New: keyed by org_id, all events for org go to same channel
    event_channels: RwLock<HashMap<Uuid, broadcast::Sender<FlovynEvent>>>,
}

#[async_trait]
impl EventPublisher for InMemoryEventPublisher {
    async fn publish_stream(&self, event: TaskStreamEvent) -> Result<(), StreamError> {
        let tx = self.get_or_create_stream_channel(&event.workflow_execution_id);
        let _ = tx.send(event);
        Ok(())
    }

    async fn publish_event(&self, event: FlovynEvent) -> Result<(), StreamError> {
        let tx = self.get_or_create_event_channel(event.org_id);
        let _ = tx.send(event);
        Ok(())
    }
}

impl StreamSubscriber for InMemoryEventPublisher {
    fn subscribe_stream(&self, workflow_id: &str)
        -> Pin<Box<dyn Stream<Item = TaskStreamEvent> + Send>> {
        let tx = self.get_or_create_stream_channel(workflow_id);
        Box::pin(BroadcastStream::new(tx.subscribe()).filter_map(|r| r.ok()))
    }
}

impl EventSubscriber for InMemoryEventPublisher {
    fn subscribe_events(&self, pattern: EventPattern)
        -> Pin<Box<dyn Stream<Item = FlovynEvent> + Send>> {
        let org_id = pattern.org_id.expect("org_id required for event subscription");
        let tx = self.get_or_create_event_channel(org_id);

        // Subscribe to channel, filter by pattern
        let stream = BroadcastStream::new(tx.subscribe())
            .filter_map(|r| r.ok())
            .filter(move |event| {
                let matches = pattern.matches(event);
                async move { matches }
            });

        Box::pin(stream)
    }
}
```

**NATS Backend (translates pattern to subjects):**

```rust
pub struct NatsEventPublisher {
    client: async_nats::Client,
}

#[async_trait]
impl EventPublisher for NatsEventPublisher {
    async fn publish_stream(&self, event: TaskStreamEvent) -> Result<(), StreamError> {
        let subject = format!("flovyn.stream.{}", event.workflow_execution_id);
        self.publish_to_subject(&subject, &event).await
    }

    async fn publish_event(&self, event: FlovynEvent) -> Result<(), StreamError> {
        // Full subject: flovyn.events.{org}.{event_type}
        let subject = format!("flovyn.events.{}.{}", event.org_id, event.event_type);
        self.publish_to_subject(&subject, &event).await
    }
}

impl EventSubscriber for NatsEventPublisher {
    fn subscribe_events(&self, pattern: EventPattern)
        -> Pin<Box<dyn Stream<Item = FlovynEvent> + Send>> {
        let org_id = pattern.org_id.expect("org_id required");

        // Translate pattern to NATS subject with wildcards
        let subject = match &pattern.event_type {
            None => format!("flovyn.events.{}.>", org_id),           // All events
            Some(t) if t.contains('.') => format!("flovyn.events.{}.{}", org_id, t),  // Exact
            Some(t) => format!("flovyn.events.{}.{}.>", org_id, t),  // Prefix wildcard
        };

        self.subscribe_to_subject(&subject)
    }
}
```

**Pattern Matching Examples:**

| Pattern | In-Memory | NATS Subject |
|---------|-----------|--------------|
| `all_for_org(t1)` | Filter: always true | `flovyn.events.t1.>` |
| `by_type(t1, "workflow")` | Filter: starts_with("workflow") | `flovyn.events.t1.workflow.>` |
| `by_type(t1, "workflow.completed")` | Filter: starts_with("workflow.completed") | `flovyn.events.t1.workflow.completed` |
| `by_type(t1, "webhook.github")` | Filter: starts_with("webhook.github") | `flovyn.events.t1.webhook.github.>` |

**Benefits:**

- **Same semantics**: Both backends behave identically from caller's perspective
- **In-memory is simple**: Single channel per org, filter in stream
- **NATS is efficient**: Filtering happens at broker level via subjects
- **Type-safe**: `EventPattern` is a struct, not a string
- **Extensible**: Add more pattern fields later (source, metadata, etc.)

**Migration path:**

1. Rename `InMemoryStreaming` → `InMemoryEventPublisher`
2. Add `event_channels` HashMap for `FlovynEvent`
3. Implement `EventPublisher`, `StreamSubscriber`, `EventSubscriber`
4. Same for NATS backend

**SSE streaming unchanged:**
- `publish_stream(TaskStreamEvent)` → same as today
- `subscribe_stream(workflow_id)` → same as today

**Event bus with patterns:**
- `publish_event(FlovynEvent)` → publishes to org channel (in-memory) or subject (NATS)
- `subscribe_events(pattern)` → filtered stream matching pattern

### 24.7 Target Types

| Target | Description | Use Case |
|--------|-------------|----------|
| **workflow** | Start a new workflow | Event triggers new process |
| **task** | Create a standalone task | Fire-and-forget processing |
| **promise** | Resolve/reject a promise | Continue waiting workflow |
| **webhook** | Send to external endpoint | Notify external systems |
| **event_bus** | Forward to another bus | Cross-org, archival |

### 24.8 Input Transformation

Transform event data before sending to target:

```yaml
- name: "Order notifications"
  pattern:
    type: ["order.shipped"]
  input_transformer:
    # Static values
    static:
      notification_type: "shipping"
    # Extract from event
    paths:
      order_id: "$.data.order_id"
      tracking: "$.data.tracking_number"
      customer: "$.data.customer_email"
    # Or use JavaScript
    script: |
      function transform(event) {
        return {
          to: event.data.customer_email,
          subject: `Order ${event.data.order_id} shipped!`,
          tracking_url: `https://track.example.com/${event.data.tracking_number}`
        };
      }
  targets:
    - type: task
      config: { task_kind: "send-email" }
```

### 24.9 Comparison with AWS EventBridge

| Feature | AWS EventBridge | Flovyn Event Bus |
|---------|-----------------|------------------|
| **Event Sources** | AWS services, SaaS, custom | Webhooks, workflows, tasks, custom |
| **Pattern Matching** | JSON patterns | JSON patterns + JavaScript |
| **Targets** | Lambda, SQS, SNS, etc. | Workflows, tasks, promises, webhooks |
| **Schema Registry** | Yes | Future consideration |
| **Archive & Replay** | Yes | Via NATS JetStream (see §25) |
| **Cross-Account** | Yes | Cross-org rules |
| **Pricing** | Per event | Self-hosted |

### 24.10 Data Model Extensions

```sql
-- Event rules table
CREATE TABLE event_rule (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES organization(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    enabled BOOLEAN NOT NULL DEFAULT true,

    -- Pattern (JSON)
    pattern JSONB NOT NULL,

    -- Transformation (optional)
    input_transformer JSONB,

    -- Metadata
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    UNIQUE(org_id, name)
);

-- Event rule targets (multiple per rule)
CREATE TABLE event_rule_target (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rule_id UUID NOT NULL REFERENCES event_rule(id) ON DELETE CASCADE,

    target_type VARCHAR(50) NOT NULL,  -- 'workflow', 'task', 'promise', 'webhook'
    target_config JSONB NOT NULL,

    -- Ordering
    priority INT NOT NULL DEFAULT 0,

    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Event log (optional, for debugging/replay)
CREATE TABLE event_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    org_id UUID NOT NULL REFERENCES organization(id),

    event_id VARCHAR(255) NOT NULL,
    source VARCHAR(255) NOT NULL,
    event_type VARCHAR(255) NOT NULL,
    data JSONB,
    correlation_id VARCHAR(255),

    received_at TIMESTAMPTZ NOT NULL DEFAULT now(),

    -- Indexing
    UNIQUE(org_id, event_id)
);

CREATE INDEX idx_event_log_type ON event_log(org_id, event_type, received_at DESC);
CREATE INDEX idx_event_log_correlation ON event_log(org_id, correlation_id);
```

### 24.11 API Design

```
# Event Rules
POST   /api/orgs/{slug}/event-rules
GET    /api/orgs/{slug}/event-rules
GET    /api/orgs/{slug}/event-rules/{id}
PUT    /api/orgs/{slug}/event-rules/{id}
DELETE /api/orgs/{slug}/event-rules/{id}

# Test a rule against sample event
POST   /api/orgs/{slug}/event-rules/{id}/test

# Publish custom event
POST   /api/orgs/{slug}/events

# Event log (if enabled)
GET    /api/orgs/{slug}/events
GET    /api/orgs/{slug}/events/{id}
```

### 24.12 Relationship to Eventhook

The eventhook plugin (Part 1-3) becomes a **specialized event source**:

```
Eventhook                    Event Bus
┌─────────────────┐               ┌─────────────────┐
│ Ingest Endpoint │──validates───▶│ webhook.received│
│ Source Config   │   signature   │     event       │
│ Provider Config │               └────────┬────────┘
└─────────────────┘                        │
                                           ▼
                                  ┌─────────────────┐
                                  │  Event Router   │
                                  │  (Rules Engine) │
                                  └─────────────────┘
```

**Migration Path:**
1. Current: Webhook routes directly trigger workflows/tasks
2. Future: Webhook routes publish events → Event rules route to targets

This allows:
- Same event to trigger multiple workflows
- Webhook events to be archived and replayed
- Unified routing logic for all event types

### 24.13 Implementation Phases

**Phase 1: Internal Events**
- Emit workflow/task lifecycle events
- Simple rule matching (source + type)
- Single target per rule

**Phase 2: Custom Events**
- `ctx.publish_event()` API for workflows
- REST API for external event publishing
- Multiple targets per rule

**Phase 3: Advanced Routing**
- JSON pattern matching on data fields
- Input transformation (paths + JavaScript)
- Event archive and replay

**Phase 4: Integration**
- Migrate webhook routes to event rules
- Cross-org event forwarding
- Schema registry

---

## 25. Future: NATS JetStream Integration

The current webhook design processes events synchronously or via background tasks. With NATS JetStream, several enhancements become possible:

### 25.1 Current NATS in Flovyn

Flovyn already has NATS integration (`flovyn-server/server/src/streaming/nats.rs`):
- Plain pub/sub for real-time task streaming
- Fire-and-forget (no persistence)
- Used for SSE streaming to clients

### 25.2 JetStream Enhancements for Webhooks

| Feature | Current Design | With JetStream |
|---------|----------------|----------------|
| **Event Processing** | Sync or background task | Async via durable stream |
| **Durability** | Database only | Stream + Database |
| **Replay** | From database | From stream (faster) |
| **Scaling** | Single processor | Multiple consumers |
| **Exactly-once** | Via idempotency keys | Native JetStream semantics |
| **Dead Letter** | Manual retry | Automatic DLQ |

### 25.3 Architecture with JetStream

```
┌─────────────────┐     ┌──────────────────────────────────────────┐
│ Webhook Ingest  │     │              NATS JetStream              │
│    Endpoint     │────▶│                                          │
└─────────────────┘     │  ┌────────────────────────────────────┐  │
                        │  │ Stream: WEBHOOKS.events             │  │
                        │  │ Subjects: webhooks.{org}.{source}│  │
                        │  └────────────────────────────────────┘  │
                        │           │           │           │      │
                        │           ▼           ▼           ▼      │
                        │  ┌─────────┐ ┌─────────┐ ┌─────────┐     │
                        │  │Consumer │ │Consumer │ │Consumer │     │
                        │  │ (Route  │ │ (Route  │ │(Outbound│     │
                        │  │Processor│ │Processor│ │Delivery)│     │
                        │  └─────────┘ └─────────┘ └─────────┘     │
                        └──────────────────────────────────────────┘
```

### 25.4 Key Benefits

**1. Decoupled Ingest from Processing**
```rust
// Ingest endpoint: just publish and return
async fn ingest_handler(...) -> Result<Json<IngestResponse>> {
    // Store event for durability
    let event = event_repo.create(&event_data).await?;

    // Publish to JetStream (async processing)
    jetstream.publish(
        format!("webhooks.{}.{}", org_id, source_slug),
        event.id.to_string().into()
    ).await?;

    // Return immediately
    Ok(Json(IngestResponse { event_id: event.id }))
}
```

**2. Horizontal Scaling**
```rust
// Multiple consumers process events in parallel
// JetStream handles work distribution and acknowledgment
let consumer = stream
    .create_consumer(ConsumerConfig {
        durable_name: Some("webhook-processor".into()),
        ack_policy: AckPolicy::Explicit,
        max_deliver: 5,  // Retry up to 5 times
        ..Default::default()
    })
    .await?;
```

**3. Dead Letter Queue for Failed Events**
```rust
// Events that fail all retries go to DLQ
let dlq_consumer = stream
    .create_consumer(ConsumerConfig {
        durable_name: Some("webhook-dlq".into()),
        filter_subject: "webhooks.*.*.dlq".into(),
        ..Default::default()
    })
    .await?;
```

**4. Event Replay from Stream**
```rust
// Replay events from a specific time
let consumer = stream
    .create_consumer(ConsumerConfig {
        deliver_policy: DeliverPolicy::ByStartTime {
            start_time: replay_from,
        },
        ..Default::default()
    })
    .await?;
```

**5. Fan-out to Multiple Processors**
```yaml
# Different consumers for different purposes
consumers:
  - name: route-processor      # Evaluate routes, trigger actions
  - name: analytics            # Track metrics, usage
  - name: audit-log            # Write to audit trail
  - name: outbound-delivery    # Forward to external systems
```

### 25.5 Subject Hierarchy

```
webhooks.{org_id}.{source_slug}.inbound     # Inbound events
webhooks.{org_id}.{source_slug}.outbound    # Outbound deliveries
webhooks.{org_id}.{source_slug}.dlq         # Dead letter queue
webhooks.{org_id}.*.metrics                 # Metrics aggregation
```

### 25.6 Implementation Phases

**Phase 1 (Current)**: Database-backed processing
- Events stored in PostgreSQL
- Background task processes events
- Idempotency via database constraints

**Phase 2 (With JetStream)**: Stream-backed processing
- Events published to JetStream after database write
- Consumers process from stream
- Database is source of truth, stream is processing queue

**Phase 3 (Advanced)**: Full event sourcing
- JetStream as primary event store
- Database materialized from stream
- Full replay capability

### 25.7 Configuration

```toml
[plugins.eventhook.nats]
enabled = true
stream_name = "WEBHOOKS"
max_age_days = 30
replicas = 3

[plugins.eventhook.nats.consumers]
route_processor = { max_deliver = 5, ack_wait_secs = 30 }
outbound_delivery = { max_deliver = 10, ack_wait_secs = 60 }
```

---

## 26. References

### Internal
- `crates/auth-script/` - QuickJS-based JavaScript execution (reuse for transformations)
- `.dev/docs/design/20251224_support-different-auth-scenarios.md` - Authenticator/Authorizer patterns
- `.dev/docs/design/20251224_add-authorization-to-entrypoints.md` - Cedar policies

### External
- [Svix Webhooks](https://github.com/svix/svix-webhooks) - Rust webhook infrastructure
- [Convoy](https://github.com/frain-dev/convoy) - Go eventhook plugin
- [n8n](https://github.com/n8n-io/n8n) - Workflow automation platform
- [Standard Webhooks](https://www.standardwebhooks.com/) - Webhook signature specification
- [JMESPath](https://jmespath.org/) - JSON query language
- [QuickJS](https://bellard.org/quickjs/) - Embeddable JavaScript engine
- [n8n HTTP Request Node](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.httprequest/) - n8n HTTP documentation
